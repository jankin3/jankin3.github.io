<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Those who cannot remember the past are condemned to repeat it.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-16T10:53:42.896Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jankin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker-summary</title>
    <link href="http://yoursite.com/2020/02/16/docker-summary/"/>
    <id>http://yoursite.com/2020/02/16/docker-summary/</id>
    <published>2020-02-16T10:46:43.000Z</published>
    <updated>2020-02-16T10:53:42.896Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/docker-summary.png" alt="avatar"></p><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>参考：<a href="https://yeasy.gitbooks.io/docker_practice/advanced_network/port_mapping.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/advanced_network/port_mapping.html</a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="docker是什么"><a href="#docker是什么" class="headerlink" title="docker是什么"></a>docker是什么</h3><ul><li>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口</li></ul><h3 id="目的：提供运行环境"><a href="#目的：提供运行环境" class="headerlink" title="目的：提供运行环境"></a>目的：提供运行环境</h3><a id="more"></a><h3 id="类比虚拟机"><a href="#类比虚拟机" class="headerlink" title="类比虚拟机"></a>类比虚拟机</h3><ul><li><p>相同点</p><ul><li>都提供环境</li></ul></li><li><p>不同点</p><ul><li>docker 更加轻便轻量级</li></ul></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>Docker 是服务器—-客户端架构</li></ul><h2 id="基本组成元素"><a href="#基本组成元素" class="headerlink" title="基本组成元素"></a>基本组成元素</h2><h3 id="镜像，镜像是一些打包好的已有的环境，可以被用来启动和创建容器，本身不能被直接修改"><a href="#镜像，镜像是一些打包好的已有的环境，可以被用来启动和创建容器，本身不能被直接修改" class="headerlink" title="镜像，镜像是一些打包好的已有的环境，可以被用来启动和创建容器，本身不能被直接修改"></a>镜像，镜像是一些打包好的已有的环境，可以被用来启动和创建容器，本身不能被直接修改</h3><h3 id="容器，容器是镜像的实例化，是可以修改的，但是都是临时修改。"><a href="#容器，容器是镜像的实例化，是可以修改的，但是都是临时修改。" class="headerlink" title="容器，容器是镜像的实例化，是可以修改的，但是都是临时修改。"></a>容器，容器是镜像的实例化，是可以修改的，但是都是临时修改。</h3><h3 id="仓库，存储和分发镜像的地方"><a href="#仓库，存储和分发镜像的地方" class="headerlink" title="仓库，存储和分发镜像的地方"></a>仓库，存储和分发镜像的地方</h3><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul><li><p>镜像</p><ul><li>创建镜像：docker image buid -t image_name .</li><li>查看镜像：docker image ls</li><li>拉取镜像：docker image pull xxxx</li></ul></li><li><p>容器</p><ul><li><p>启动</p><ul><li><p>新建并启动：</p><ul><li><p>docker container run image_name</p></li><li><p>原理解释</p><ul><li><ol><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li></ol></li><li><ol start="2"><li>利用镜像创建并启动一个容器</li></ol></li><li><ol start="3"><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li></ol></li><li><ol start="4"><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li></ol></li><li><ol start="5"><li>从地址池配置一个 ip 地址给容器</li></ol></li><li><ol start="6"><li>执行用户指定的应用程序</li></ol></li><li><ol start="7"><li>执行完毕后容器被终止</li></ol></li></ul></li></ul></li><li><p>启动已终止的容器：docker container start</p></li></ul></li><li><p>列出容器：docker container ls (–all包括已经死掉的)</p></li><li><p>终止容器：docker container kill container_id</p></li><li><p>清理容器文件：docker container rm container_id</p></li><li><p>进入容器(常用)：docker exec -it container_id bash </p><p>-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</p></li></ul></li></ul><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><ul><li><p>作用：管理多个 Docker 容器</p></li><li><p>模板文件(核心)</p><ul><li><p>控制镜像</p><ul><li>注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。</li></ul></li></ul></li><li><p>常用操作</p><ul><li><p>启动</p><ul><li><code>docker-compose up</code>,非常有用，它将尝试自动完成包括构建镜像,创建服务，启动服务，并关联服务相关容器的一系列操作</li></ul></li><li><p>停止</p><ul><li>docker-compose down 此命令将会停止 up 命令所启动的容器，并移除网络</li></ul></li></ul></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>一般情况下使用仓库的镜像就够了，但是当不满足使用的时候我们就可以自己制作镜像</p><ul><li><p>方式一. docker commit，通过修改容器配置并保存形成新的镜像,(不推荐，原因黑箱操作，资源冗余)</p></li><li><p>方式二.dockerfile</p><ul><li><p>原理：把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像</p></li><li><p>模板文件命令</p><ul><li><p>RUN，容器构建阶段执行的操作,</p></li><li><p>CMD，容器启动命令,用于指定默认的容器主进程的启动命令</p></li><li><p>ENTRYPOINT</p><ul><li><p>特点：类似于CMD操作</p></li><li><p>作用：当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令</p></li><li><p>为什么要这么设计呢？应用</p><ul><li>1.方便添加用户自定义参数</li><li>2.应用运行前可以做一些准备工作</li></ul></li></ul></li></ul></li><li><p>构建镜像命令</p><ul><li><p><code>docker build -t image_name .</code></p><p>注意，这里理解最后一个点，表示当前目录，上下文的意思。基于docker的c/s架构，当我们执行构建镜像的时候其实操作是在服务器端(Docker 引擎)中构建。但是这时需要本地的文件的时候，就有了上下文的作用，docker build会将该路径下的文件传到服务器端(所以位置很重要)。</p></li><li><p>其他用法，docker build 还支持从 URL，tar 压缩包 ，标准输入等构建；</p></li></ul></li></ul></li></ul><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><ul><li>原理与实现：主要通过 Linux 上的 iptables 防火墙来进行管理和实现，配置–iptables=true|false 是否允许 Docker 添加 iptables 规则</li><li>外部访问内部：主机端口映射</li><li>内部访问外部:容器要想访问外部网络，需要本地系统的转发支持</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      docker总结
    
    </summary>
    
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>oauth</title>
    <link href="http://yoursite.com/2020/02/16/oauth/"/>
    <id>http://yoursite.com/2020/02/16/oauth/</id>
    <published>2020-02-16T06:21:26.000Z</published>
    <updated>2020-02-16T09:29:18.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/oauth.png" alt="avatar"></p><h1 id="oauth"><a href="#oauth" class="headerlink" title="oauth"></a>oauth</h1><h2 id="oauth是什么？"><a href="#oauth是什么？" class="headerlink" title="oauth是什么？"></a>oauth是什么？</h2><h3 id="一个开放标准，允许用户-无需提供将用户名和密码-让第三方应用访问该用户在某一网站上存储的私密的资源"><a href="#一个开放标准，允许用户-无需提供将用户名和密码-让第三方应用访问该用户在某一网站上存储的私密的资源" class="headerlink" title="一个开放标准，允许用户(无需提供将用户名和密码)让第三方应用访问该用户在某一网站上存储的私密的资源"></a>一个开放标准，允许用户(无需提供将用户名和密码)让第三方应用访问该用户在某一网站上存储的私密的资源</h3><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><a id="more"></a><p>参考：<a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p><h3 id="提供一个token令牌"><a href="#提供一个token令牌" class="headerlink" title="提供一个token令牌"></a>提供一个token令牌</h3><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><ul><li><p>特点：短期，可撤销，有范围</p></li><li><p>如何获取token</p><ul><li><p>方式</p><ul><li><p>授权码（authorization-code）</p><ul><li>特点：最常用最安全，适用于有后端的web项目</li><li>实现：前端返回code，后端使用code请求token</li></ul></li><li><p>隐藏式（implicit）</p><ul><li>实现：直接请求token</li></ul></li><li><p>密码式（password）</p><ul><li>风险很大，直接告诉账号密码</li></ul></li><li><p>客户端凭证（client credentials）</p><ul><li>适用于没有前端的命令行应用，即在命令行下请求令牌</li></ul></li></ul></li></ul></li><li><p>使用token</p><ul><li>一般在请求头添加”Authorization: Bearer ACCESS_TOKEN”</li></ul></li><li><p>更新token</p><ul><li>一般会一起返回一个refresh_token，用于刷新token</li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>参考：google登录官方文档<br><a href="https://developers.google.com/identity/protocols/OAuth2" target="_blank" rel="noopener">https://developers.google.com/identity/protocols/OAuth2</a></p><h3 id="三方登录"><a href="#三方登录" class="headerlink" title="三方登录"></a>三方登录</h3><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><h3 id="openId"><a href="#openId" class="headerlink" title="openId"></a>openId</h3><h3 id="openId-connect"><a href="#openId-connect" class="headerlink" title="openId connect"></a>openId connect</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://q4b6m25wx.bkt.clouddn.com/xmind/oauth.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;oauth&quot;&gt;&lt;a href=&quot;#oauth&quot; class=&quot;headerlink&quot; title=&quot;oauth&quot;&gt;&lt;/a&gt;oauth&lt;/h1&gt;&lt;h2 id=&quot;oauth是什么？&quot;&gt;&lt;a href=&quot;#oauth是什么？&quot; class=&quot;headerlink&quot; title=&quot;oauth是什么？&quot;&gt;&lt;/a&gt;oauth是什么？&lt;/h2&gt;&lt;h3 id=&quot;一个开放标准，允许用户-无需提供将用户名和密码-让第三方应用访问该用户在某一网站上存储的私密的资源&quot;&gt;&lt;a href=&quot;#一个开放标准，允许用户-无需提供将用户名和密码-让第三方应用访问该用户在某一网站上存储的私密的资源&quot; class=&quot;headerlink&quot; title=&quot;一个开放标准，允许用户(无需提供将用户名和密码)让第三方应用访问该用户在某一网站上存储的私密的资源&quot;&gt;&lt;/a&gt;一个开放标准，允许用户(无需提供将用户名和密码)让第三方应用访问该用户在某一网站上存储的私密的资源&lt;/h3&gt;&lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="协议" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>python-defaultdict</title>
    <link href="http://yoursite.com/2020/02/07/python-defaultdict/"/>
    <id>http://yoursite.com/2020/02/07/python-defaultdict/</id>
    <published>2020-02-07T02:49:21.000Z</published>
    <updated>2020-02-07T10:10:28.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h1><h3 id="问题索引"><a href="#问题索引" class="headerlink" title="问题索引"></a>问题索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计字典的相同值的出现的所有的键(类似（键-值对组成的）序列转换为（键-列表组成的）字典)</span></span><br><span class="line">dict1 = &#123;<span class="number">1</span>:<span class="string">'a'</span>,<span class="number">2</span>:<span class="string">'b'</span>,<span class="number">3</span>:<span class="string">'a'</span>&#125;</span><br><span class="line"><span class="comment"># 方式1 原生字典</span></span><br><span class="line">summary_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="keyword">if</span> summary_dict.get(v, <span class="literal">False</span>):</span><br><span class="line">        summary_dict[v].append(k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        summary_dict[v] = [k,]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 方式二 setdefault()</span></span><br><span class="line"><span class="comment"># 字典setdefault() 函数和 get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值  </span></span><br><span class="line">summary_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict1.items():</span><br><span class="line">    summary_dict.setdefault(v, []).append(k)</span><br></pre></td></tr></table></figure><p>不足：每次对于k是否已经存在统计字典中药增加一个判断，方式的if-else, 方式二的setdefault(),简单的说就是一个初始化. 而<code>defaultdict</code>的出现刚好解决了这个问题.</p><h3 id="defaultdict-是什么"><a href="#defaultdict-是什么" class="headerlink" title="defaultdict 是什么"></a>defaultdict 是什么</h3><p>官方文档:<a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict</a></p><p>概述: <code>返回一个新的类似字典的对象。 defaultdict 是内置 dict 类的子类</code>。<br>它重载了一个方法并添加了一个可写的实例变量，其中keys的值，自行确定赋值，但是values的类型，是function_factory的类实例，而且具有默认值。比如default(int)则创建一个类似dictionary对象，里面任何的values都是int的实例，而且就算是一个不存在的key, d[key] 也有一个默认值，这个默认值是int()的默认值0</p><h3 id="defaultdict-解决了什么问题？"><a href="#defaultdict-解决了什么问题？" class="headerlink" title="defaultdict 解决了什么问题？"></a>defaultdict 解决了什么问题？</h3><p>初始化问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式三 defaultdict</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">dict1 = &#123;<span class="number">1</span>:<span class="string">'a'</span>,<span class="number">2</span>:<span class="string">'b'</span>,<span class="number">3</span>:<span class="string">'a'</span>&#125;</span><br><span class="line">summary_dict = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict1.items():</span><br><span class="line">    summary_dict[v].append(k)</span><br><span class="line"><span class="comment">#官方解释 当每个键第一次遇见时，它还没有在字典里面，所以自动创建该条目，即调用 default_factory 方法，返回一个空的 list。 list.append() 操作添加值到这个新的列表里。当再次存取该键时，就正常操作，list.append() 添加另一个值到列表中。这个计数比它的等价方法 dict.setdefault() 要快速和简单：</span></span><br></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p> 使用 list 作为 default_factory，很轻松地将（键-值对组成的）序列转换为（键-列表组成的）字典，同上例</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ol><li>关于collections</li></ol><table><thead><tr><th align="left">模块</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">namedtuple()</td><td align="left">创建命名元组子类的工厂函数</td></tr><tr><td align="left">deque</td><td align="left">类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)</td></tr><tr><td align="left">ChainMap</td><td align="left">类似字典(dict)的容器类，将多个映射集合到一个视图里面</td></tr><tr><td align="left">Counter</td><td align="left">字典的子类，提供了可哈希对象的计数功能</td></tr><tr><td align="left">OrderedDict</td><td align="left">字典的子类，保存了他们被添加的顺序</td></tr><tr><td align="left">defaultdict</td><td align="left">字典的子类，提供了一个工厂函数，为字典查询提供一个默认值</td></tr><tr><td align="left">UserDict</td><td align="left">封装了字典对象，简化了字典子类化</td></tr><tr><td align="left">UserList</td><td align="left">封装了列表对象，简化了列表子类化</td></tr><tr><td align="left">UserString</td><td align="left">封装了列表对象，简化了字符串子类化</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      python defaultdict 使用
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>algorithm--dynamic-programming</title>
    <link href="http://yoursite.com/2020/02/02/algorithm-dynamic-programming/"/>
    <id>http://yoursite.com/2020/02/02/algorithm-dynamic-programming/</id>
    <published>2020-02-01T16:08:05.000Z</published>
    <updated>2020-02-01T16:19:14.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/algorithm--dynamic-programming.png" alt="avatar"></p><h1 id="算法-动态规划"><a href="#算法-动态规划" class="headerlink" title="算法-动态规划"></a>算法-动态规划</h1><p>Those who cannot remember the past are condemned to repeat it.</p><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么?"></a>它是什么?</h2><h3 id="Dynamic-programming，简称DP。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。"><a href="#Dynamic-programming，简称DP。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。" class="headerlink" title="Dynamic programming，简称DP。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。"></a>Dynamic programming，简称DP。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</h3><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul><li>记住已经求过的子问题的解</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><ul><li><p>爬楼梯问题</p></li><li><p>01背包问题</p><ul><li>问题描述，给定一组n个物品，每种物品都有自己的重量w和价值v，在限定的总重量/总容量内，选择其中若干个（也即每种物品可以选0个或1个），设计选择方案使得物品的总价值最高</li><li>思考:其他方式不可以么？比如，性价比计算，只拿贵的？答案，不行，只拿按照单个物品性价比高的情况下怎么使空间全部占满？所以总体计算下来单个性价比最高不一定等于总体性价比最高</li></ul></li></ul><h3 id="做过的算法题目"><a href="#做过的算法题目" class="headerlink" title="做过的算法题目"></a>做过的算法题目</h3><ul><li><p>解码方法问题</p><p><a href="https://github.com/jankin3/project-leetcode/blob/master/91-Decode-Ways-analysis.md" target="_blank" rel="noopener">https://github.com/jankin3/project-leetcode/blob/master/91-Decode-Ways-analysis.md</a></p></li><li><p>分词问题</p><p><a href="https://github.com/jankin3/project-leetcode/blob/master/139-wordbreak-analysis.md" target="_blank" rel="noopener">https://github.com/jankin3/project-leetcode/blob/master/139-wordbreak-analysis.md</a></p></li><li><p>最佳买卖股票时机含冷冻期 问题</p><p><a href="https://github.com/jankin3/project-leetcode/blob/master/309-best-time-to-buy-and-sell-stock-with-cooldown-analysis.md" target="_blank" rel="noopener">https://github.com/jankin3/project-leetcode/blob/master/309-best-time-to-buy-and-sell-stock-with-cooldown-analysis.md</a></p></li></ul><h2 id="它有什么？"><a href="#它有什么？" class="headerlink" title="它有什么？"></a>它有什么？</h2><h3 id="两个要素"><a href="#两个要素" class="headerlink" title="两个要素"></a>两个要素</h3><ul><li>状态转移方程</li><li>临界条件</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>重叠子问题和最优子结构</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>表格</p><ul><li>目的就是去不断推导，完成状态转移， 表格中的每一个cell都是一个小问题， 我们先解决规模为寻常的情况，然后根据这个结果逐步推导</li></ul></li></ul><h2 id="关联算法"><a href="#关联算法" class="headerlink" title="关联算法"></a>关联算法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>参考:<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md</a></p><ul><li><p>对比</p><ul><li>递归，从问题的结果倒推，直到问题的规模缩小到寻常。</li><li>动态规划，就是从寻常入手， 逐步扩大规模到最优子结构</li></ul></li></ul><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><ul><li>to do</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      算法-动态规划
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>thoughts-996</title>
    <link href="http://yoursite.com/2020/01/31/thoughts-996/"/>
    <id>http://yoursite.com/2020/01/31/thoughts-996/</id>
    <published>2020-01-31T11:24:13.000Z</published>
    <updated>2020-01-31T11:30:01.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观《奇葩说》对于996是否该886-有感"><a href="#观《奇葩说》对于996是否该886-有感" class="headerlink" title="观《奇葩说》对于996是否该886 有感"></a>观《奇葩说》<code>对于996是否该886</code> 有感</h1><h3 id="对于996，我从内心其实是支持的。"><a href="#对于996，我从内心其实是支持的。" class="headerlink" title="对于996，我从内心其实是支持的。"></a>对于996，我从内心其实是支持的。</h3><p>今天看了奇葩说刚好讲到了这个,主要精彩不是正式辩论。而是赛后几位导师的总结</p><a id="more"></a><p>薛兆丰教授说了了几个观点:</p><p>1.每个人每个时候都是在为了自己的简历打工。 竞争时代，996的原因不是老板要求你的996，而是有愿意996的员工，这份工作你不愿意，有人愿意去。竞争时代，这个时代总有人比你更加聪明更加努力。我们的努力更重要的为了自己的简历。</p><ul><li>‘当别人问你要不要对996说886的时候？（掷地有声，铿锵有力）要’</li><li>‘当别人问是否反对996制度？（掷地有声，铿锵有力）要’</li><li>‘我们自己要不要996？要’<br>(太真实了)</li></ul><p><code>很认同，个人认为工作的两个目的，1. 钱 2. 个人能力的成长</code></p><p>2.(什么样的工作更可能是996？)资本密集的地方劳动力就高。在资本多变化大劳动力特别大的地方，那些工作岗位对劳动力的付费更高。</p><p><code>对于程序员而言确实如此。对比同学，我确实很幸运，能够进入互联网行业，能够拿到如此的薪资。抓住时代。</code></p><p>3.在公司里面你对老板有多大的议价权和议价能力，议价权是你在别处的机会。如果你在别处有很多的机会，你可以去和老板谈离职加薪。</p><p><code>当我们问自己能拿多少工资的时候？我觉得更多的是看自己的价值所在，最简单就是你值多少钱，而不是去盲目和同学同行对比，看着别人拿了高薪而去眼红。</code></p><hr><p>李诞有几句话说的很好，</p><ol><li>正方辩手你当时说：’妈妈心疼你，说你的身体很重要。’ 但是我想问， ‘你妈妈的身体不重要么？我们还可以依赖妈妈多久？’， 当我们感到轻松的时候是有人在替我们负重前行</li><li>快乐是短暂的，人不可能一天都在笑。让人活下来的是意义，只有工作才是人生的意义所在。</li></ol>]]></content>
    
    <summary type="html">
    
      观《奇葩说》`对于996是否该886` 有感
    
    </summary>
    
    
    
      <category term="996" scheme="http://yoursite.com/tags/996/"/>
    
      <category term="有感" scheme="http://yoursite.com/tags/%E6%9C%89%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>mind-mapping</title>
    <link href="http://yoursite.com/2020/01/29/mind-mapping/"/>
    <id>http://yoursite.com/2020/01/29/mind-mapping/</id>
    <published>2020-01-29T14:26:29.000Z</published>
    <updated>2020-01-29T14:32:32.509Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/mind-mapping.png" alt="avatar"></p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="他是什么"><a href="#他是什么" class="headerlink" title="他是什么"></a>他是什么</h3><ul><li>输入是繁杂的关系，输出是知识网络</li></ul><h3 id="他的目的"><a href="#他的目的" class="headerlink" title="他的目的"></a>他的目的</h3><ul><li>归纳精简知识</li><li>拆分知识</li><li>避免学习误区，达到学习的原则</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>学习知识</li></ul><h3 id="使用原则：满足学习原则的要求，而不是盲目信仰"><a href="#使用原则：满足学习原则的要求，而不是盲目信仰" class="headerlink" title="使用原则：满足学习原则的要求，而不是盲目信仰"></a>使用原则：满足学习原则的要求，而不是盲目信仰</h3><h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><ul><li><p>收集例子</p></li><li><p>自我思考</p><ul><li><p>一阶知识</p><ul><li><p>分类</p><ul><li>它是什么</li><li>为什么是</li></ul></li><li><p>回归</p><ul><li>他的目的</li><li>如何达到</li></ul></li></ul></li><li><p>二阶知识</p><ul><li><p>组合关系</p><ul><li>它有什么</li></ul></li><li><p>执行步骤</p><ul><li>如何达到</li></ul></li></ul></li></ul></li></ul><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><h3 id="使用误区"><a href="#使用误区" class="headerlink" title="使用误区"></a>使用误区</h3><ul><li>是用来整理的，不是拿来记忆的</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      思维导图
    
    </summary>
    
    
    
      <category term="tool" scheme="http://yoursite.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>study-understand</title>
    <link href="http://yoursite.com/2020/01/29/study-understand/"/>
    <id>http://yoursite.com/2020/01/29/study-understand/</id>
    <published>2020-01-29T14:13:32.000Z</published>
    <updated>2020-01-29T14:25:47.228Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/study-understand.png" alt="avatar"></p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="它是什么？"><a href="#它是什么？" class="headerlink" title="它是什么？"></a>它是什么？</h2><a id="more"></a><h3 id="从有限的问题和答案中找出规律的过程。"><a href="#从有限的问题和答案中找出规律的过程。" class="headerlink" title="从有限的问题和答案中找出规律的过程。"></a>从有限的问题和答案中找出规律的过程。</h3><h2 id="它的目的？"><a href="#它的目的？" class="headerlink" title="它的目的？"></a>它的目的？</h2><h3 id="解决未知情况。"><a href="#解决未知情况。" class="headerlink" title="解决未知情况。"></a>解决未知情况。</h3><h2 id="如何学习？"><a href="#如何学习？" class="headerlink" title="如何学习？"></a>如何学习？</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>明确输入输出</li><li>将信息压缩成知识</li><li>用例子重塑大脑连接</li><li>二阶知识拆分知识</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>搞清楚输入输出</p><p>先搞清楚什么是问题和答案?而不是简单的知识描述.<br>这一点深有体会，当读书的时候，比如《高性能mysql》，看第一遍的时候只是觉得卧槽这个设计牛皮？其实我只是看了一遍知识的描述。实际的知识并没有学会多少。我的问题是什么？我为什么要看这本书？我希望收获什么？这个设计的原因是什么？解决了什么问题？没有解决什么问题？什么情况下使用？这些问题是我需要注意的地方</p></li><li><p>通过大量的已知例子去归纳总结知识</p></li><li><p>验证知识的正确性</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>思维 导图</li></ul><h2 id="学习的误区"><a href="#学习的误区" class="headerlink" title="学习的误区?"></a>学习的误区?</h2><h3 id="一般-错误-的学习方法"><a href="#一般-错误-的学习方法" class="headerlink" title="一般(错误)的学习方法:"></a>一般(错误)的学习方法:</h3><ul><li><ol><li>阅读知识的描述</li></ol></li><li><ol start="2"><li>理解描述的含义</li></ol></li><li><ol start="3"><li>反复描述希望记住</li></ol></li></ul><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><ul><li>不搞清楚输入输出</li><li>学习方式错误，比如光靠记忆</li><li>不使用例子学习</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      study
    
    </summary>
    
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>annual-year-2019</title>
    <link href="http://yoursite.com/2020/01/21/annual-year-2019/"/>
    <id>http://yoursite.com/2020/01/21/annual-year-2019/</id>
    <published>2020-01-21T08:58:06.000Z</published>
    <updated>2020-02-16T09:46:08.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019年总结"><a href="#2019年总结" class="headerlink" title="2019年总结"></a>2019年总结</h1><blockquote><p>适应和胜任工作要求，编程的习惯的养成，开始读书充电和总结知识体系，遇到一些问题并学会去解决  –jankin的2019年度总结</p></blockquote><a id="more"></a><h2 id="适应和胜任工作"><a href="#适应和胜任工作" class="headerlink" title="适应和胜任工作"></a>适应和胜任工作</h2><p><code>整体考虑</code>，<code>主动性</code>，<code>责任感</code>，<code>独当一面</code>，如果用词语概括今年工作的收获的话。进入工作一年半了，自己最大的感受就是如何去做好一份工作。 且不论coding能力的高低，也有很多东西值得体会和去学习。</p><h2 id="编程的习惯养成"><a href="#编程的习惯养成" class="headerlink" title="编程的习惯养成"></a>编程的习惯养成</h2><blockquote><p>你不必在技术上很在行，但你必须有能引导你变得在行的特质──机敏、有想法、善于观察、乐于主动参与解决问题。</p></blockquote><p><code>编程的理解</code>，今年对编程有了一些新的理解。编程就想是造房子，一个项目就是一个建造一个建筑。大到每个房屋之间怎么配合协调，小到这块装那块瓦怎么放置，都是工程师去设计并实现。当我们去做具体的需要的时候，尽可能的去考虑整体的设计以及兼顾细节的完美，才能编写出艺术品，而不是简单的代码机器的产物。</p><p><code>编程的能力</code>，从编程的能力来说，一些小的总结和一些有待改进</p><ul><li>总结</li></ul><ol><li>解决问题，善于利用google和stackoverflow去快速解决常见的问题</li><li>抓住问题，google和stackoverflow可以快速的找到解决方案,但并不应该只是按照这个上面的copy下来运行一下可以解决问题就完事了。每一个问题都是宝贵的财富，不要避开问题，多看文档多查资料多学习去解决问题，网络可以快速找到解决方案但是方案背后的原理需要去琢磨</li><li>整理归纳，基本功不够扎实，比如经常用到的时间模块，每次使用还是要去现场查资料，没有google开发进度为0。意识到这个问题之后今年开始写博客开始整理了，也算是一个不小的改善了，嘿嘿嘿。</li></ol><ul><li>有待改进：</li></ul><ol><li>多注重技术层次的思考，能够完成基本需求的同时应该去思考技术的本身，提升技术，毕竟技术是安家立命之本。</li></ol><h2 id="开始读书充电"><a href="#开始读书充电" class="headerlink" title="开始读书充电"></a>开始读书充电</h2><p>今年。读了《python核心编程》,《高性能mysql》,《从小工到专家》.没读完的《编程珠玑》《深入理解nginx》《鸟哥的私房菜》。买了很多技术书籍，看进去的不多。从收获上来说确实有所收获，但是也发现了一些问题。<br>问题:当需要用到一些书中东西的时候，脑袋不是特别的清晰。<br>问题原因: <code>缺少思考与整理</code>，读书不是读小说翻完了就OK了<br>新的认识:书籍是作者按照他的思路与思维模式去编写的知识载体，对于自己来说，我们拥有自己的知识网络，我们需要理解去归纳到自己的知识网络。</p><h2 id="遇到一些问题并解决"><a href="#遇到一些问题并解决" class="headerlink" title="遇到一些问题并解决"></a>遇到一些问题并解决</h2><p>遇到一个问题，<code>从日常需求来说其实都比较杂乱，经常做了之后没有足够的满足感和成就感。具体的实际影响就是比较累而且收获不大</code>。<br>深入思考了这个问题很久，我的解决方案</p><ol><li><code>心态</code>，作为一个刚进入工作的年轻人，应该去感激每一个机会去学习去积累</li><li><code>技术的思考</code>，当你做简单的事情的时候，有没有考虑你是否是站在巨人的肩膀上，才显得特别轻松。当你用bootstrap的时候有没有考虑过为什么这个框架这么受欢迎？他是怎么实现的？为什么laravel比TP好用？为什么选择mysql数据库？简单的东西需要去思考去研究。</li><li><code>业务的思考</code>，当新的需要提出的时候，应该是考虑此需求背后的具体的问题点是什么，从工程师的角度是否有更好的方式去解决，而不是只是想一个代码机器去执行PM的需求文档里面的流程。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，2019年是我的一个开启之年。开始进入工作状态，开始学会去编程，开始不断的充电，当然也开始遇到问题并学会去解决。2020，新的一年，加油!</p>]]></content>
    
    <summary type="html">
    
      2019-summary
    
    </summary>
    
    
    
      <category term="summary" scheme="http://yoursite.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>linux-filesystem</title>
    <link href="http://yoursite.com/2020/01/21/linux-filesystem/"/>
    <id>http://yoursite.com/2020/01/21/linux-filesystem/</id>
    <published>2020-01-21T06:56:32.000Z</published>
    <updated>2020-01-21T07:07:42.956Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/linux-filesystem.png" alt="avatar"></p><h1 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h1><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ul><li>索引式文件系统. 读取文件的时候读取inode中的block 位置之后可以一口气直接找到所有的block。这里对比U盘的FAT系统需要一个个读取，因为每个block 文件里面记录着下一个block的位置，相比而言会比较慢</li></ul><h3 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h3><ul><li>boot sector, superblock, inode bitmap, block bitmap, inode table, data block</li></ul><h3 id="文件-系统主要信息"><a href="#文件-系统主要信息" class="headerlink" title="文件 系统主要信息"></a>文件 系统主要信息</h3><ul><li><code>superblock</code>, 记录整个文件系统的整体信息</li><li><code>inode</code>, 文件的权限与属性,一个文件占用一个inode, 以及block 的位置</li><li><code>block</code>, 数据区块, 记录文件的实际存储数据</li></ul><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><h3 id="目录和文件类似，每个目录都有一个inode-和block-inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode"><a href="#目录和文件类似，每个目录都有一个inode-和block-inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode" class="headerlink" title="目录和文件类似，每个目录都有一个inode 和block, inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode"></a>目录和文件类似，每个目录都有一个inode 和block, inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode</h3><h2 id="日志式文件系统"><a href="#日志式文件系统" class="headerlink" title="日志式文件系统"></a>日志式文件系统</h2><h3 id="目的-数据一致性检查"><a href="#目的-数据一致性检查" class="headerlink" title="目的:数据一致性检查"></a>目的:数据一致性检查</h3><h3 id="实现-多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；"><a href="#实现-多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；" class="headerlink" title="实现:多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；"></a>实现:多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；</h3><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><ul><li><p>目的:列出文件系统的整体磁盘使用量</p></li><li><p>常用</p><ul><li>-h 显示各文件系统的容量</li><li>-i -h 显示各文件系统inode使用情况</li></ul></li></ul><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><ul><li>评估文件系统的磁盘使用量</li><li>du -h –max-depth=1 计算当前目录下的文件或者目录的大小，包括子目录</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      linux文件系统
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>http-client-cache</title>
    <link href="http://yoursite.com/2020/01/19/http-client-cache/"/>
    <id>http://yoursite.com/2020/01/19/http-client-cache/</id>
    <published>2020-01-19T08:48:57.000Z</published>
    <updated>2020-01-19T08:57:08.125Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/http-client-cache.png" alt="avatar"></p><h1 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h1><p>参考:<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a></p><h2 id="作用-网络提取内容开销大，客户端直接缓存数据"><a href="#作用-网络提取内容开销大，客户端直接缓存数据" class="headerlink" title="作用:  网络提取内容开销大，客户端直接缓存数据"></a>作用:  网络提取内容开销大，客户端直接缓存数据</h2><h2 id="问题：如何兼顾客户端缓存和快速更新"><a href="#问题：如何兼顾客户端缓存和快速更新" class="headerlink" title="问题：如何兼顾客户端缓存和快速更新"></a>问题：如何兼顾客户端缓存和快速更新</h2><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><a id="more"></a><h3 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h3><ul><li><p>ETag: 验证令牌,资源未发生变化时不会传送任何数据</p></li><li><p>Cache-Control</p><ul><li><p>概览：定义其缓存策略,也就是如何缓存各个响应以及缓存多久</p></li><li><p>详细配置</p><ul><li>“no-cache”和“no-store”</li><li>“public”与 “private”</li><li>“max-age”</li></ul></li></ul></li></ul><h3 id="实际设计"><a href="#实际设计" class="headerlink" title="实际设计:"></a>实际设计:</h3><ul><li>HTML: 被标记为“no-cache”，这意味着浏览器在每次请求时都始终会重新验证文档，并在内容变化时提取最新版本</li><li>JavaScript 可以设置较长的缓存，因为添加 了版本指纹可以随时更新。</li><li>image:图像缓存时不包含版本或唯一指纹，并设置为 1 天后到期。</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      http客户端浏览器header缓存
    
    </summary>
    
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="cache" scheme="http://yoursite.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://yoursite.com/2020/01/15/nginx/"/>
    <id>http://yoursite.com/2020/01/15/nginx/</id>
    <published>2020-01-15T14:57:48.000Z</published>
    <updated>2020-01-19T07:05:38.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><h3 id="web-服务器-也可负载均衡，反向代理"><a href="#web-服务器-也可负载均衡，反向代理" class="headerlink" title="web 服务器(也可负载均衡，反向代理)"></a>web 服务器(也可负载均衡，反向代理)</h3><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="采用异步事件驱动，可大量并行处理"><a href="#采用异步事件驱动，可大量并行处理" class="headerlink" title="采用异步事件驱动，可大量并行处理"></a>采用异步事件驱动，可大量并行处理</h3><a id="more"></a><ul><li><p>linux 采用epoll 模型</p><p>epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可</p></li></ul><h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><ul><li>丰富的第三方模块</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h3><ul><li><p>块配置 event,http, server</p></li><li><p>配置项</p><ul><li>格式: 多个值用空格隔开</li><li>单位：通用单位</li><li>变量：少数模块支持，同php</li></ul></li></ul><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p><a href="https://segmentfault.com/a/1190000013267839" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013267839</a></p><ul><li><p>作用: 根据url匹配对应处理规则</p></li><li><p>语法规则</p><ul><li>location [ = | ~ | <del>* | ^</del> ] uri { … }<br>location @name { … }</li></ul></li><li><p>匹配规则</p><ul><li><p>前缀匹配</p><ul><li>= 表示精确匹配</li><li>^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找</li><li>字符串 会相互比较选择匹配度最高的, 一般配合PHP直接使用 location / 转换到php程序</li></ul></li><li><p>正则匹配</p><ul><li>~区分大小写</li><li>~* 不区分大小写</li></ul></li></ul></li></ul><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul><li><p>debug 配置</p></li><li><p>正常运行的配置</p><ul><li>env|env=value定义环境变量 (没怎么用过)</li><li>include,嵌入其他配置, 便于模块化</li><li>pid: master 进程ID的pid文件存放路径</li><li>user username groupname, worker 进程运行的用户以及用户组</li><li>worker_rlimit_nofile limit, 可以打开的最大文件句柄数</li><li>worker_rlimit_sigpending limit, 限制信号队列</li></ul></li><li><p>优化性能配置</p><ul><li>worker_processes number,worker 进程个数</li><li>worker_cpu_affinity cpumask, 绑定worker 进程到cpu内核</li><li>ssl 硬件加速</li><li>系统调用gettimeofday 的评率</li><li>worker 进程优先级</li></ul></li><li><p>时间类配置项</p><ul><li>accept锁相关</li><li>lock 文件路径</li><li>批零建立新连接</li><li>选择时间模型</li><li>每个worker 的最大连接数</li></ul></li></ul><h3 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h3><ul><li>虚拟主机与请求的分发</li><li>文件路径的定义</li><li>内存以及磁盘的分配</li><li>网络连接的设置</li><li>MIME类型的设置</li><li>对客户端请求的限制</li><li>文件操作的优化</li><li>对客户端请求的特殊处理</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      nginx 初步了解
    
    </summary>
    
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="web服务器" scheme="http://yoursite.com/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://yoursite.com/2020/01/15/npm/"/>
    <id>http://yoursite.com/2020/01/15/npm/</id>
    <published>2020-01-15T14:57:48.000Z</published>
    <updated>2020-02-23T08:39:56.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><h3 id="全称-Node-Package-Manager，即node包管理器，维基https-zh-wikipedia-org-wiki-Npm"><a href="#全称-Node-Package-Manager，即node包管理器，维基https-zh-wikipedia-org-wiki-Npm" class="headerlink" title="全称 Node Package Manager，即node包管理器，维基https://zh.wikipedia.org/wiki/Npm"></a>全称 Node Package Manager，即node包管理器，维基<a href="https://zh.wikipedia.org/wiki/Npm" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Npm</a></h3><h2 id="配置-：package-json与lockfile-锁文件"><a href="#配置-：package-json与lockfile-锁文件" class="headerlink" title="配置 ：package.json与lockfile(锁文件)"></a>配置 ：<code>package.json</code>与lockfile(锁文件)</h2><a id="more"></a><h3 id="目的，生成相同的-node-modules"><a href="#目的，生成相同的-node-modules" class="headerlink" title="目的，生成相同的 node_modules"></a>目的，<code>生成相同的 node_modules</code></h3><h3 id="为什么需要lockfile"><a href="#为什么需要lockfile" class="headerlink" title="为什么需要lockfile?"></a>为什么需要lockfile?</h3><ul><li>达成目的，存在两个主要问题，1.npm 不同版本的安装算法不一致 2.依赖包和依赖包的依赖的更新</li></ul><h3 id="package-json与lockfile-锁文件-是什么？"><a href="#package-json与lockfile-锁文件-是什么？" class="headerlink" title="package.json与lockfile(锁文件)是什么？"></a><code>package.json</code>与lockfile(锁文件)是什么？</h3><ul><li>package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息</li><li>lockfile, 锁文件，一般包括 package-lock.json 或 npm-shrinkwrap.json，以记录实际安装的各个package的具体来源和版本号</li></ul><h3 id="配合使用"><a href="#配合使用" class="headerlink" title="配合使用"></a><code>配合使用</code></h3><ul><li>如果没有lockfile, npm i会生成一个</li><li>两者兼容，根据localfile 下载</li><li>两者不兼容，会根据package.json下载，并更新lockfile</li></ul><h3 id="参考，https-juejin-im-post-5d40f9a4e51d45620821ce30，https-www-zhihu-com-question-62331583"><a href="#参考，https-juejin-im-post-5d40f9a4e51d45620821ce30，https-www-zhihu-com-question-62331583" class="headerlink" title="参考，https://juejin.im/post/5d40f9a4e51d45620821ce30，https://www.zhihu.com/question/62331583"></a>参考，<a href="https://juejin.im/post/5d40f9a4e51d45620821ce30，https://www.zhihu.com/question/62331583" target="_blank" rel="noopener">https://juejin.im/post/5d40f9a4e51d45620821ce30，https://www.zhihu.com/question/62331583</a></h3><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h3><ul><li>整体安装，不加后缀直接安装，如果node_modules存在，就不再重新安装了，即使有新，也是如此, -f 强制重新安装</li><li>单独包安装，npm install <package name>  安装模块的特定版本 use @</li></ul><h3 id="npm-ci"><a href="#npm-ci" class="headerlink" title="npm ci"></a>npm ci</h3><ul><li>特点，整体安装，适合安装干净依赖的情况，快速，更严格，依赖于完整的配置，不会修改文件</li><li>原理，根据 package-lock.json 去安装确定的依赖，package.json 只是用来验证是不是有不匹配的版本，若有则报错</li></ul><h2 id="常用功能与命令"><a href="#常用功能与命令" class="headerlink" title="常用功能与命令"></a>常用功能与命令</h2><h3 id="查看包版本npm-list"><a href="#查看包版本npm-list" class="headerlink" title="查看包版本npm list"></a>查看包版本npm list</h3><ul><li>-g 全局，默认当前项目下的所有模块以及依赖</li><li>npm list packagename 查看单独模块</li></ul><h3 id="切换镜像"><a href="#切换镜像" class="headerlink" title="切换镜像"></a>切换镜像</h3><ul><li>临时使用，npm –registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> install express</li><li>永久使用，npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>(验证npm config get registry)</li><li>通过cnpm，npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li><li>问题，使用cnpm install 之后的东西不受lockfile 控制，有点坑</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      nginx 初步了解
    
    </summary>
    
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
      <category term="package.json&amp;&amp;lockfile" scheme="http://yoursite.com/tags/package-json-lockfile/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="http://yoursite.com/2020/01/13/http/"/>
    <id>http://yoursite.com/2020/01/13/http/</id>
    <published>2020-01-13T00:28:17.000Z</published>
    <updated>2020-01-17T07:27:11.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>引用: <a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">https://juejin.im/entry/5981c5df518825359a2b9476</a></p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h3 id="客户端（用户）和服务端（网站）之间请求和应答的标准"><a href="#客户端（用户）和服务端（网站）之间请求和应答的标准" class="headerlink" title="客户端（用户）和服务端（网站）之间请求和应答的标准"></a>客户端（用户）和服务端（网站）之间请求和应答的标准</h3><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><a id="more"></a><h3 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http 1.0"></a>http 1.0</h3><h3 id="http-1-x"><a href="#http-1-x" class="headerlink" title="http 1.x"></a>http 1.x</h3><ul><li><p>改进之处</p><ul><li><p>缓存处理</p></li><li><p>带宽优化及网络连接的使用</p><ul><li>允许只请求资源的某个部分</li></ul></li><li><p>错误通知的管理</p><ul><li>新增了24个错误状态响应码</li></ul></li><li><p>Host头处理</p><ul><li>HTTP1.1的请求消息和响应消息都应支持Host头域</li></ul></li><li><p>长连接</p><ul><li>Connection： keep-alive</li></ul></li></ul></li></ul><h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><ul><li><p>基于google提出的SPDY</p></li><li><p>改进之处</p><ul><li>新的二进制格式</li><li>多路复用(区别于长连接)</li><li>header压缩</li><li>服务端推送</li></ul></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ul><li><p>是什么？</p><ul><li>超文本传输安全协议</li></ul></li><li><p>过程</p><ul><li>HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包</li></ul></li><li><p>区别</p><ul><li>http:运行在TCP之上，所有传输的内容都是明文</li><li>https:运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li></ul></li></ul><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;引用: &lt;a href=&quot;https://juejin.im/entry/5981c5df518825359a2b9476&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/entry/5981c5df518825359a2b9476&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h2&gt;&lt;h3 id=&quot;应用层协议&quot;&gt;&lt;a href=&quot;#应用层协议&quot; class=&quot;headerlink&quot; title=&quot;应用层协议&quot;&gt;&lt;/a&gt;应用层协议&lt;/h3&gt;&lt;h3 id=&quot;客户端（用户）和服务端（网站）之间请求和应答的标准&quot;&gt;&lt;a href=&quot;#客户端（用户）和服务端（网站）之间请求和应答的标准&quot; class=&quot;headerlink&quot; title=&quot;客户端（用户）和服务端（网站）之间请求和应答的标准&quot;&gt;&lt;/a&gt;客户端（用户）和服务端（网站）之间请求和应答的标准&lt;/h3&gt;&lt;h2 id=&quot;发展&quot;&gt;&lt;a href=&quot;#发展&quot; class=&quot;headerlink&quot; title=&quot;发展&quot;&gt;&lt;/a&gt;发展&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>mysql-explain</title>
    <link href="http://yoursite.com/2019/12/19/mysql-explain/"/>
    <id>http://yoursite.com/2019/12/19/mysql-explain/</id>
    <published>2019-12-19T15:04:57.000Z</published>
    <updated>2020-01-17T07:27:29.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-explain"><a href="#mysql-explain" class="headerlink" title="mysql explain"></a>mysql explain</h1><h2 id="作用：sql查询如何执行，近似结果"><a href="#作用：sql查询如何执行，近似结果" class="headerlink" title="作用：sql查询如何执行，近似结果"></a>作用：sql查询如何执行，近似结果</h2><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><a id="more"></a><h3 id="explain-extend"><a href="#explain-extend" class="headerlink" title="explain extend"></a>explain extend</h3><h3 id="explain-partitions"><a href="#explain-partitions" class="headerlink" title="explain partitions"></a>explain partitions</h3><h2 id="主要行解释"><a href="#主要行解释" class="headerlink" title="主要行解释"></a>主要行解释</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul><li><p>编号，</p><p>标识select 所属行，id越大越先执行，id相同顺序执行</p></li></ul><h3 id="select-type"><a href="#select-type" class="headerlink" title="select type"></a>select type</h3><ul><li>显示对应行是简单还是复杂查询</li></ul><h3 id="type-访问类型"><a href="#type-访问类型" class="headerlink" title="type(访问类型)"></a>type(访问类型)</h3><ul><li><p>NULL</p></li><li><p>const、system</p></li><li><p>eq_ref</p></li><li><p>ref</p></li><li><p>range</p></li><li><p>index</p><ul><li>全表扫描，按照索引</li></ul></li><li><p>ALL</p><ul><li>全表扫描，按行</li></ul></li></ul><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><ul><li>显示正在访问的表</li></ul><h3 id="ken-len"><a href="#ken-len" class="headerlink" title="ken_len"></a>ken_len</h3><ul><li>索引使用字节数</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h3 id="row"><a href="#row" class="headerlink" title="row"></a>row</h3><ul><li>估计读取行数</li></ul><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>参考：<a href="https://www.cnblogs.com/kerrycode/p/9909093.html" target="_blank" rel="noopener">https://www.cnblogs.com/kerrycode/p/9909093.html</a></p><ul><li>Using temporary</li><li>Using filesort</li><li>Using Index</li><li>Using Index Condition</li><li>Using where</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql-explain&quot;&gt;&lt;a href=&quot;#mysql-explain&quot; class=&quot;headerlink&quot; title=&quot;mysql explain&quot;&gt;&lt;/a&gt;mysql explain&lt;/h1&gt;&lt;h2 id=&quot;作用：sql查询如何执行，近似结果&quot;&gt;&lt;a href=&quot;#作用：sql查询如何执行，近似结果&quot; class=&quot;headerlink&quot; title=&quot;作用：sql查询如何执行，近似结果&quot;&gt;&lt;/a&gt;作用：sql查询如何执行，近似结果&lt;/h2&gt;&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;h2 id=&quot;相关&quot;&gt;&lt;a href=&quot;#相关&quot; class=&quot;headerlink&quot; title=&quot;相关&quot;&gt;&lt;/a&gt;相关&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>shell-script</title>
    <link href="http://yoursite.com/2019/12/12/shell-script/"/>
    <id>http://yoursite.com/2019/12/12/shell-script/</id>
    <published>2019-12-12T11:10:38.000Z</published>
    <updated>2020-01-17T07:27:49.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h1><h2 id="作用：处理用户和系统的交互"><a href="#作用：处理用户和系统的交互" class="headerlink" title="作用：处理用户和系统的交互"></a>作用：处理用户和系统的交互</h2><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><p>详细请看<a href="https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1</a></p><h2 id="相关拓展"><a href="#相关拓展" class="headerlink" title="相关拓展"></a>相关拓展</h2><a id="more"></a><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>原文:<a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/11/bash-set.html</a></p><ul><li><p>问题：</p><ul><li>目前shell 遇到错误不会自动暂停，会继续向下执行，这个其他python之类程序有很大不同，很可能产生和预期不一样的结果</li></ul></li><li><p>解决:set command用来定制环境</p><ul><li><p>-u 遇到不存在的变量报错(同-o nounset)</p></li><li><p>错误处理</p><ul><li><p>command || exit 1</p></li><li><p>-e:发生错误，就终止执行(同-o errexit)</p></li><li><p>特殊对于管道命令</p><ul><li>特殊性：Bash 会把最后一个子命令的返回值，作为整个命令的返回值</li><li>set -o pipefail:个人理解是把管道内部命令抛出去然后外部-e 会捕获，所以对于管道内部其实还是会继续执行操作</li></ul></li></ul></li><li><p>-x 输出详细输入输出(同-o xtrace)</p></li><li><p>汇总:</p><ul><li>shell 内部：set -euxo pipefail（推荐）</li><li>执行时：bash -euxo pipefail xxx.sh</li></ul></li></ul></li></ul><h3 id="ssh交互"><a href="#ssh交互" class="headerlink" title="ssh交互"></a>ssh交互</h3><ul><li><p>简介:ssh 不单可以登录，可以直接执行相关命令ssh <a href="mailto:nick@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">nick@xxx.xxx.xxx.xxx</a> “df -h”</p></li><li><p>shell  中需要与remote server 交互</p><ul><li><p>简单命令</p><ul><li>可以直接放在后面,使用引号, 例如ssh  $remote_host “mysqldump -uxxx-pxxx xxx”</li><li>缺点：(不能传递变量)</li></ul></li><li><p>复杂命令</p><ul><li>想要实现复杂的命令,可以写在外部脚本中</li><li>eg:ssh <a href="mailto:nick@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">nick@xxx.xxx.xxx.xxx</a> ‘bash -s’ &lt; test.sh var1 var2</li></ul></li></ul></li></ul><h3 id="相关操作符"><a href="#相关操作符" class="headerlink" title="相关操作符"></a>相关操作符</h3><ul><li><a href="https://blog.csdn.net/x1269778817/article/details/46535729" target="_blank" rel="noopener">https://blog.csdn.net/x1269778817/article/details/46535729</a></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shell-脚本&quot;&gt;&lt;a href=&quot;#shell-脚本&quot; class=&quot;headerlink&quot; title=&quot;shell 脚本&quot;&gt;&lt;/a&gt;shell 脚本&lt;/h1&gt;&lt;h2 id=&quot;作用：处理用户和系统的交互&quot;&gt;&lt;a href=&quot;#作用：处理用户和系统的交互&quot; class=&quot;headerlink&quot; title=&quot;作用：处理用户和系统的交互&quot;&gt;&lt;/a&gt;作用：处理用户和系统的交互&lt;/h2&gt;&lt;h2 id=&quot;语法基础&quot;&gt;&lt;a href=&quot;#语法基础&quot; class=&quot;headerlink&quot; title=&quot;语法基础&quot;&gt;&lt;/a&gt;语法基础&lt;/h2&gt;&lt;p&gt;详细请看&lt;a href=&quot;https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关拓展&quot;&gt;&lt;a href=&quot;#相关拓展&quot; class=&quot;headerlink&quot; title=&quot;相关拓展&quot;&gt;&lt;/a&gt;相关拓展&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql-lock</title>
    <link href="http://yoursite.com/2019/12/09/mysql-lock/"/>
    <id>http://yoursite.com/2019/12/09/mysql-lock/</id>
    <published>2019-12-09T15:58:44.000Z</published>
    <updated>2020-01-17T07:27:36.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-锁机制"><a href="#mysql-锁机制" class="headerlink" title="mysql 锁机制"></a>mysql 锁机制</h1><p><a href="https://learnku.com/articles/28772#c812c1" target="_blank" rel="noopener">https://learnku.com/articles/28772#c812c1</a> 锁机制</p><h2 id="作用：解决并发访问"><a href="#作用：解决并发访问" class="headerlink" title="作用：解决并发访问"></a>作用：解决并发访问</h2><h2 id="所处的处置：一般-表锁在mysql-server层，行锁在索引层"><a href="#所处的处置：一般-表锁在mysql-server层，行锁在索引层" class="headerlink" title="所处的处置：一般,表锁在mysql server层，行锁在索引层"></a>所处的处置：一般,表锁在mysql server层，行锁在索引层</h2><a id="more"></a><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><ul><li><p>表锁</p></li><li><p>行锁</p><ul><li>实现方式：索引加锁</li></ul></li><li><p>页锁</p></li></ul><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul><li><p>写锁</p><ul><li>for update. 比读锁有更高的优先级</li></ul></li><li><p>读锁</p><ul><li>lock in share mode, 普通select innodb不会有任何锁</li></ul></li></ul><h3 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h3><ul><li><p>记录锁</p></li><li><p>间隙锁</p></li><li><p>next-key锁</p></li><li><p>意向锁</p><ul><li>是一个标记锁，为了实现表锁和行锁不同的锁粒度</li></ul></li><li><p>插入意向锁</p></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql-锁机制&quot;&gt;&lt;a href=&quot;#mysql-锁机制&quot; class=&quot;headerlink&quot; title=&quot;mysql 锁机制&quot;&gt;&lt;/a&gt;mysql 锁机制&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://learnku.com/articles/28772#c812c1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learnku.com/articles/28772#c812c1&lt;/a&gt; 锁机制&lt;/p&gt;
&lt;h2 id=&quot;作用：解决并发访问&quot;&gt;&lt;a href=&quot;#作用：解决并发访问&quot; class=&quot;headerlink&quot; title=&quot;作用：解决并发访问&quot;&gt;&lt;/a&gt;作用：解决并发访问&lt;/h2&gt;&lt;h2 id=&quot;所处的处置：一般-表锁在mysql-server层，行锁在索引层&quot;&gt;&lt;a href=&quot;#所处的处置：一般-表锁在mysql-server层，行锁在索引层&quot; class=&quot;headerlink&quot; title=&quot;所处的处置：一般,表锁在mysql server层，行锁在索引层&quot;&gt;&lt;/a&gt;所处的处置：一般,表锁在mysql server层，行锁在索引层&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="lock" scheme="http://yoursite.com/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>string-decode</title>
    <link href="http://yoursite.com/2019/12/09/string-decode/"/>
    <id>http://yoursite.com/2019/12/09/string-decode/</id>
    <published>2019-12-09T15:13:12.000Z</published>
    <updated>2020-01-20T07:36:50.578Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/string-encode-decode.png" alt="avatar"></p><h1 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h1><p>发展与概述文章<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p><h2 id="作用-使机器识别不同的字符串"><a href="#作用-使机器识别不同的字符串" class="headerlink" title="作用:使机器识别不同的字符串"></a>作用:使机器识别不同的字符串</h2><h2 id="编码分类与发展"><a href="#编码分类与发展" class="headerlink" title="编码分类与发展"></a>编码分类与发展</h2><h3 id="编码发展"><a href="#编码发展" class="headerlink" title="编码发展"></a>编码发展</h3><ul><li><p>ASCII</p><ul><li>英语字符和二进制位对应</li></ul></li><li><p>unicode</p><ul><li>概述:字符集,所有的字符对应二进制位，但是没有规定这个二进制代码应该如何存储</li><li>优点:实现了统一 的编码</li><li>缺点:如何存储编码?兼容之后的资源浪费？</li></ul></li><li><p>utf-8</p><ul><li><p>概述:针对Unicode的可变长度字符编码实现，使用1~4个字节表示一个符号</p></li><li><p>特点:</p><ul><li>兼容ASCII. ASCII是UTF-8的一个子集</li></ul></li></ul></li><li><p>UCS-2和UCS-4:文字和代码点之间的对应关系</p></li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul><li>unicode 与utf-8: utf-8是Unicode的一种实现方式,从计算机工作方式来说一般在utf-8是用来存储和传输，unicode 一般用来转换</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="python2-编码问题"><a href="#python2-编码问题" class="headerlink" title="python2 编码问题"></a>python2 编码问题</h3><p>细节请看：<a href="https://www.jianshu.com/p/58d5f64813dc" target="_blank" rel="noopener">https://www.jianshu.com/p/58d5f64813dc</a></p><ul><li><p>type:str与unicode</p><ul><li>str 是Unicode经过编码的字节</li><li>真正的字符串</li></ul></li><li><p>类型转换</p><ul><li>2种类型的字符串都提供了 encode 和 decode 方法，通过类型转换解决问题</li></ul></li><li><p>坑</p><ul><li>编码、解码:python 会隐式地进行，默认采用 sys.setdefaultencoding()(一般是ascii)</li><li>标准输出,ptint会按照 sys.stdout.encoding 来给 unicode 编码，交给操作系统输出</li></ul></li></ul><h3 id="python去除文本中的emoji"><a href="#python去除文本中的emoji" class="headerlink" title="python去除文本中的emoji"></a>python去除文本中的emoji</h3><ul><li>问题描述: mysql utf8 不兼容emoji(utf8mb4 兼容),如何remove?</li><li>思路: 找到unicode中四字节字符删除</li><li>具体:<figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">highpoints = re.compile(u&apos;[\U00010000-\U0010ffff]&apos;) # UCS-4</span><br><span class="line">highpoints = re.compile(u&apos;[\uD800-\uDBFF][\uDC00-\uDFFF]&apos;) # UCS-2</span><br></pre></td></tr></table></figure></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://q4b6m25wx.bkt.clouddn.com/xmind/string-encode-decode.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;字符串编码&quot;&gt;&lt;a href=&quot;#字符串编码&quot; class=&quot;heade
      
    
    </summary>
    
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>python-datetime</title>
    <link href="http://yoursite.com/2019/12/01/python-datetime/"/>
    <id>http://yoursite.com/2019/12/01/python-datetime/</id>
    <published>2019-12-01T14:46:31.000Z</published>
    <updated>2020-01-17T07:27:42.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-时间和日期"><a href="#python-时间和日期" class="headerlink" title="python 时间和日期"></a>python 时间和日期</h1><h2 id="时间字符串格式化"><a href="#时间字符串格式化" class="headerlink" title="时间字符串格式化"></a>时间字符串格式化</h2><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior</a></p><h3 id="时间元组转换成字符串-strptime"><a href="#时间元组转换成字符串-strptime" class="headerlink" title="时间元组转换成字符串: strptime(),"></a>时间元组转换成字符串: strptime(),</h3><a id="more"></a><h3 id="字符串转换成时间元组-strftime"><a href="#字符串转换成时间元组-strftime" class="headerlink" title="字符串转换成时间元组:strftime(),"></a>字符串转换成时间元组:strftime(),</h3><h2 id="时间换算"><a href="#时间换算" class="headerlink" title="时间换算"></a>时间换算</h2><h3 id="主要是datetime-timedelta"><a href="#主要是datetime-timedelta" class="headerlink" title="主要是datetime.timedelta()"></a>主要是datetime.timedelta()</h3><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/datetime.html</a></p><ul><li><p>有效类型</p><ul><li>date</li><li>time</li><li>datetime</li><li>timedelta</li><li>tzinfo</li><li>timezone</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-时间和日期&quot;&gt;&lt;a href=&quot;#python-时间和日期&quot; class=&quot;headerlink&quot; title=&quot;python 时间和日期&quot;&gt;&lt;/a&gt;python 时间和日期&lt;/h1&gt;&lt;h2 id=&quot;时间字符串格式化&quot;&gt;&lt;a href=&quot;#时间字符串格式化&quot; class=&quot;headerlink&quot; title=&quot;时间字符串格式化&quot;&gt;&lt;/a&gt;时间字符串格式化&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;时间元组转换成字符串-strptime&quot;&gt;&lt;a href=&quot;#时间元组转换成字符串-strptime&quot; class=&quot;headerlink&quot; title=&quot;时间元组转换成字符串: strptime(),&quot;&gt;&lt;/a&gt;时间元组转换成字符串: strptime(),&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux-file-permission</title>
    <link href="http://yoursite.com/2019/11/24/linux-file-permission/"/>
    <id>http://yoursite.com/2019/11/24/linux-file-permission/</id>
    <published>2019-11-24T15:56:57.000Z</published>
    <updated>2020-01-17T07:27:20.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-文件权限"><a href="#linux-文件权限" class="headerlink" title="linux 文件权限"></a>linux 文件权限</h1><h2 id="文件权限：每个文件可以针对每个用户具有不同的权限"><a href="#文件权限：每个文件可以针对每个用户具有不同的权限" class="headerlink" title="文件权限：每个文件可以针对每个用户具有不同的权限"></a>文件权限：每个文件可以针对每个用户具有不同的权限</h2><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="为什么要有这么细致的分级？"><a href="#为什么要有这么细致的分级？" class="headerlink" title="为什么要有这么细致的分级？"></a>为什么要有这么细致的分级？</h3><ul><li>安全防护，因为linux多用户，多任务的环境。每个用户的权限隐私很重要</li></ul><h3 id="文件用户身份"><a href="#文件用户身份" class="headerlink" title="文件用户身份"></a>文件用户身份</h3><ul><li><p>own/group/other</p><a id="more"></a><h3 id="权限等级与意义"><a href="#权限等级与意义" class="headerlink" title="权限等级与意义"></a>权限等级与意义</h3></li><li><p>read</p><ul><li>对文件: 读取文件</li><li>对目录:读取该目录结构</li></ul></li><li><p>write</p><ul><li>对文件: 包括编辑新增等，但是不包括删除, 那么怎么才能删除文件呢？</li><li>对目录:更改目录结构的，包括增删改，注意删除的权限在这里</li></ul></li><li><p>execute</p><ul><li>对文件:可执行</li><li>对目录:注意，代表用户是否可以进入该目录，区分与r权限</li></ul></li></ul><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><h3 id="定义-一个文件拥有的属性"><a href="#定义-一个文件拥有的属性" class="headerlink" title="定义:一个文件拥有的属性"></a>定义:一个文件拥有的属性</h3><h3 id="内容包括-权限，连接，所有者，用户组，文件容量，修改日期，文件名"><a href="#内容包括-权限，连接，所有者，用户组，文件容量，修改日期，文件名" class="headerlink" title="内容包括:权限，连接，所有者，用户组，文件容量，修改日期，文件名"></a>内容包括:权限，连接，所有者，用户组，文件容量，修改日期，文件名</h3><h3 id="command-chgrp-chown-chmod"><a href="#command-chgrp-chown-chmod" class="headerlink" title="command:chgrp/chown/chmod"></a>command:chgrp/chown/chmod</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;linux-文件权限&quot;&gt;&lt;a href=&quot;#linux-文件权限&quot; class=&quot;headerlink&quot; title=&quot;linux 文件权限&quot;&gt;&lt;/a&gt;linux 文件权限&lt;/h1&gt;&lt;h2 id=&quot;文件权限：每个文件可以针对每个用户具有不同的权限&quot;&gt;&lt;a href=&quot;#文件权限：每个文件可以针对每个用户具有不同的权限&quot; class=&quot;headerlink&quot; title=&quot;文件权限：每个文件可以针对每个用户具有不同的权限&quot;&gt;&lt;/a&gt;文件权限：每个文件可以针对每个用户具有不同的权限&lt;/h2&gt;&lt;h2 id=&quot;用户和用户组&quot;&gt;&lt;a href=&quot;#用户和用户组&quot; class=&quot;headerlink&quot; title=&quot;用户和用户组&quot;&gt;&lt;/a&gt;用户和用户组&lt;/h2&gt;&lt;h3 id=&quot;为什么要有这么细致的分级？&quot;&gt;&lt;a href=&quot;#为什么要有这么细致的分级？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有这么细致的分级？&quot;&gt;&lt;/a&gt;为什么要有这么细致的分级？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;安全防护，因为linux多用户，多任务的环境。每个用户的权限隐私很重要&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;文件用户身份&quot;&gt;&lt;a href=&quot;#文件用户身份&quot; class=&quot;headerlink&quot; title=&quot;文件用户身份&quot;&gt;&lt;/a&gt;文件用户身份&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;own/group/other&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest 与 js</title>
    <link href="http://yoursite.com/2019/11/22/XMLHttpRequest/"/>
    <id>http://yoursite.com/2019/11/22/XMLHttpRequest/</id>
    <published>2019-11-21T16:53:02.000Z</published>
    <updated>2020-01-17T07:27:55.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XMLHttpRequest是什么？"><a href="#XMLHttpRequest是什么？" class="headerlink" title="XMLHttpRequest是什么？"></a>XMLHttpRequest是什么？</h3><p>XMLHttpRequest是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。<br>关联: 有了XMLHttpRequest对象。ajax操作因此得以诞生。所以在这里 ajax，是一种技术方案</p><h3 id="js-ajax发送请求"><a href="#js-ajax发送请求" class="headerlink" title="js ajax发送请求"></a>js ajax发送请求</h3><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// get</span><br><span class="line">var httpRequest = new XMLHttpRequest();//第一步：建立所需的对象</span><br><span class="line">httpRequest.open(&apos;GET&apos;, &apos;url&apos;, true);//第二步：打开连接  将请求参数写在url中  ps:&quot;./Ptest.php?name=test&amp;nameone=testone&quot;</span><br><span class="line">httpRequest.send();//第三步：发送请求  将请求参数写在URL中</span><br><span class="line">httpRequest.onreadystatechange = function () &#123;</span><br><span class="line">    if (httpRequest.readyState == 4 &amp;&amp; httpRequest.status == 200) &#123;</span><br><span class="line">        var json = httpRequest.responseText;</span><br><span class="line">        console.log(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">// post</span><br><span class="line">var httpRequest = new XMLHttpRequest();//第一步：创建需要的对象</span><br><span class="line">httpRequest.open(&apos;POST&apos;, &apos;url&apos;, true); //第二步：打开连接</span><br><span class="line">httpRequest.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//设置请求头 注：post方式必须设置请求头（在建立连接后设置请求头）</span><br><span class="line">httpRequest.send(&apos;name=teswe&amp;ee=ef&apos;);//发送请求 将情头体写在send中</span><br><span class="line">httpRequest.onreadystatechange = function () &#123;//请求后的回调接口，可将请求成功后要执行的程序写在其中</span><br><span class="line">    if (httpRequest.readyState == 4 &amp;&amp; httpRequest.status == 200) &#123;//验证请求是否发送成功</span><br><span class="line">        var json = httpRequest.responseText;//获取到服务端返回的数据</span><br><span class="line">        console.log(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="js-发送非ajax请求"><a href="#js-发送非ajax请求" class="headerlink" title="js 发送非ajax请求"></a>js 发送非ajax请求</h3><p>get 请求就不必多说了。 <code>windows.location.href = &#39;url&#39;;</code><br>post, 我是模拟表单进行提交post请求</p><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var temp = document.createElement(&quot;form&quot;);</span><br><span class="line">temp.action = &apos;%s&apos;;</span><br><span class="line">temp.method = &quot;post&quot;;</span><br><span class="line">temp.style.display = &quot;none&quot;;</span><br><span class="line">form_data = &#123;</span><br><span class="line">    &apos;action&apos;: &apos;applycoupon&apos;,</span><br><span class="line">    &apos;couponcode&apos;: &apos;%s&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">for(var key in form_data)&#123;</span><br><span class="line">    var opt = document.createElement(&quot;textarea&quot;);</span><br><span class="line">    opt.name = key;</span><br><span class="line">    opt.value = form_data[key];</span><br><span class="line">    temp.appendChild(opt);</span><br><span class="line">&#125;</span><br><span class="line">document.body.appendChild(temp);</span><br><span class="line">temp.submit();</span><br></pre></td></tr></table></figure><p>这里主要理解XMLHttpRequest是什么，具体代码细节不细说了，请参考</p><blockquote><p><a href="https://segmentfault.com/a/1190000004322487#articleHeader18" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004322487#articleHeader18</a><br><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XMLHttpRequest是什么？&quot;&gt;&lt;a href=&quot;#XMLHttpRequest是什么？&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest是什么？&quot;&gt;&lt;/a&gt;XMLHttpRequest是什么？&lt;/h3&gt;&lt;p&gt;XMLHtt
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
