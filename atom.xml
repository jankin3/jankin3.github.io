<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>2020, 稳定前行</title>
  
  <subtitle>忘记历史, 必将重蹈覆辙 --动态规划</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-21T09:06:58.408Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jankin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>annual-year-2019</title>
    <link href="http://yoursite.com/2020/01/21/annual-year-2019/"/>
    <id>http://yoursite.com/2020/01/21/annual-year-2019/</id>
    <published>2020-01-21T08:58:06.000Z</published>
    <updated>2020-01-21T09:06:58.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作，编程，读书，问题-–2019年总结"><a href="#工作，编程，读书，问题-–2019年总结" class="headerlink" title="工作，编程，读书，问题  –2019年总结"></a>工作，编程，读书，问题  –2019年总结</h1><a id="more"></a><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p><code>整体考虑</code>，<code>主动性</code>，<code>责任感</code>，<code>独当一面</code>，如果用词语概括今年工作的收获的话。工作会伴随我们大半生的时间。进入工作一年半了，自己最大的感受就是如何去做好一份工作。 且不论coding能力的高低，也有很多东西值得体会和去学习。</p><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><blockquote><p>你不必在技术上很在行，但你必须有能引导你变得在行的特质──机敏、有想法、善于观察、乐于主动参与解决问题。</p></blockquote><p><code>编程的理解</code>，今年对编程有了一些新的理解。编程就想是造房子，一个项目就是一个建造一个建筑。大到每个房屋之间怎么配合协调，小到这块装那块瓦怎么放置，都是工程师去设计并实现。当我们去做具体的需要的时候，尽可能的去考虑整体的设计以及兼顾细节的完美，才能编写出艺术品，而不是简单的代码机器的产物。</p><p><code>编程的能力</code>，从编程的能力来说，一些小的总结和一些有待改进</p><ul><li>总结</li></ul><ol><li>解决问题，善于利用google和stackoverflow去快速解决常见的问题</li><li>抓住问题，google和stackoverflow可以快速的找到解决方案,但并不应该只是按照这个上面的copy下来运行一下可以解决问题就完事了。每一个问题都是宝贵的财富，不要避开问题，多看文档多查资料多学习去解决问题，网络可以快速找到解决方案但是方案背后的原理需要去琢磨</li><li>整理归纳，基本功不够扎实，比如经常用到的时间模块，每次使用还是要去现场查资料，没有google开发进度为0。意识到这个问题之后今年开始写博客开始整理了，也算是一个不小的改善了，嘿嘿嘿。</li></ol><ul><li>有待改进：</li></ul><ol><li>多注重技术层次的思考，能够完成基本需求的同时应该去思考技术的本身，提升技术，毕竟技术是安家立命之本。</li></ol><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>今年。读了《python核心编程》,《高性能mysql》,《从小工到专家》.没读完的《编程珠玑》《深入理解nginx》《鸟哥的私房菜》。买了很多技术书籍，看进去的不多。从收获上来说确实有所收获，但是也发现了一些问题。<br>问题:当需要用到一些书中东西的时候，脑袋不是特别的清晰。<br>问题原因: <code>缺少思考与整理</code>，读书不是读小说翻完了就OK了<br>新的认识:书籍是作者按照他的思路与思维模式去编写的知识载体，对于自己来说，我们拥有自己的知识网络，我们需要理解去归纳到自己的知识网络。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>遇到一个问题，<code>从日常需求来说其实都比较杂乱，经常做了之后没有足够的满足感和成就感。具体的实际影响就是比较累而且收获不大</code>。<br>深入思考了这个问题很久，我的解决方案</p><ol><li><code>心态</code>，作为一个刚进入工作的年轻人，应该去感激每一个机会去学习去积累</li><li><code>技术的思考</code>，，当你做简单的事情的时候，有没有考虑你是否是站在巨人的肩膀上，才显得特别轻松。当你用bootstrap的时候有没有考虑过为什么这个框架这么受欢迎？他是怎么实现的？为什么laravel比TP好用？为什么选择mysql数据库？简单的东西需要去思考去研究。</li><li><code>业务的思考</code>，当新的需要提出的时候，应该是考虑此需求背后的具体的问题点是什么，从工程师的角度是否有更好的方式去解决，而不是只是想一个代码机器去执行PM的需求文档里面的流程。</li></ol>]]></content>
    
    <summary type="html">
    
      2019-summary
    
    </summary>
    
    
    
      <category term="summary" scheme="http://yoursite.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>linux-filesystem</title>
    <link href="http://yoursite.com/2020/01/21/linux-filesystem/"/>
    <id>http://yoursite.com/2020/01/21/linux-filesystem/</id>
    <published>2020-01-21T06:56:32.000Z</published>
    <updated>2020-01-21T07:07:42.956Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/linux-filesystem.png" alt="avatar"></p><h1 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h1><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ul><li>索引式文件系统. 读取文件的时候读取inode中的block 位置之后可以一口气直接找到所有的block。这里对比U盘的FAT系统需要一个个读取，因为每个block 文件里面记录着下一个block的位置，相比而言会比较慢</li></ul><h3 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h3><ul><li>boot sector, superblock, inode bitmap, block bitmap, inode table, data block</li></ul><h3 id="文件-系统主要信息"><a href="#文件-系统主要信息" class="headerlink" title="文件 系统主要信息"></a>文件 系统主要信息</h3><ul><li><code>superblock</code>, 记录整个文件系统的整体信息</li><li><code>inode</code>, 文件的权限与属性,一个文件占用一个inode, 以及block 的位置</li><li><code>block</code>, 数据区块, 记录文件的实际存储数据</li></ul><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><h3 id="目录和文件类似，每个目录都有一个inode-和block-inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode"><a href="#目录和文件类似，每个目录都有一个inode-和block-inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode" class="headerlink" title="目录和文件类似，每个目录都有一个inode 和block, inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode"></a>目录和文件类似，每个目录都有一个inode 和block, inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode</h3><h2 id="日志式文件系统"><a href="#日志式文件系统" class="headerlink" title="日志式文件系统"></a>日志式文件系统</h2><h3 id="目的-数据一致性检查"><a href="#目的-数据一致性检查" class="headerlink" title="目的:数据一致性检查"></a>目的:数据一致性检查</h3><h3 id="实现-多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；"><a href="#实现-多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；" class="headerlink" title="实现:多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；"></a>实现:多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；</h3><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><ul><li><p>目的:列出文件系统的整体磁盘使用量</p></li><li><p>常用</p><ul><li>-h 显示各文件系统的容量</li><li>-i -h 显示各文件系统inode使用情况</li></ul></li></ul><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><ul><li>评估文件系统的磁盘使用量</li><li>du -h –max-depth=1 计算当前目录下的文件或者目录的大小，包括子目录</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      linux文件系统
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>http-client-cache</title>
    <link href="http://yoursite.com/2020/01/19/http-client-cache/"/>
    <id>http://yoursite.com/2020/01/19/http-client-cache/</id>
    <published>2020-01-19T08:48:57.000Z</published>
    <updated>2020-01-19T08:57:08.125Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/http-client-cache.png" alt="avatar"></p><h1 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h1><p>参考:<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a></p><h2 id="作用-网络提取内容开销大，客户端直接缓存数据"><a href="#作用-网络提取内容开销大，客户端直接缓存数据" class="headerlink" title="作用:  网络提取内容开销大，客户端直接缓存数据"></a>作用:  网络提取内容开销大，客户端直接缓存数据</h2><h2 id="问题：如何兼顾客户端缓存和快速更新"><a href="#问题：如何兼顾客户端缓存和快速更新" class="headerlink" title="问题：如何兼顾客户端缓存和快速更新"></a>问题：如何兼顾客户端缓存和快速更新</h2><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><a id="more"></a><h3 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h3><ul><li><p>ETag: 验证令牌,资源未发生变化时不会传送任何数据</p></li><li><p>Cache-Control</p><ul><li><p>概览：定义其缓存策略,也就是如何缓存各个响应以及缓存多久</p></li><li><p>详细配置</p><ul><li>“no-cache”和“no-store”</li><li>“public”与 “private”</li><li>“max-age”</li></ul></li></ul></li></ul><h3 id="实际设计"><a href="#实际设计" class="headerlink" title="实际设计:"></a>实际设计:</h3><ul><li>HTML: 被标记为“no-cache”，这意味着浏览器在每次请求时都始终会重新验证文档，并在内容变化时提取最新版本</li><li>JavaScript 可以设置较长的缓存，因为添加 了版本指纹可以随时更新。</li><li>image:图像缓存时不包含版本或唯一指纹，并设置为 1 天后到期。</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      http客户端浏览器header缓存
    
    </summary>
    
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="cache" scheme="http://yoursite.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://yoursite.com/2020/01/15/nginx/"/>
    <id>http://yoursite.com/2020/01/15/nginx/</id>
    <published>2020-01-15T14:57:48.000Z</published>
    <updated>2020-01-19T07:05:38.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><h3 id="web-服务器-也可负载均衡，反向代理"><a href="#web-服务器-也可负载均衡，反向代理" class="headerlink" title="web 服务器(也可负载均衡，反向代理)"></a>web 服务器(也可负载均衡，反向代理)</h3><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="采用异步事件驱动，可大量并行处理"><a href="#采用异步事件驱动，可大量并行处理" class="headerlink" title="采用异步事件驱动，可大量并行处理"></a>采用异步事件驱动，可大量并行处理</h3><a id="more"></a><ul><li><p>linux 采用epoll 模型</p><p>epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可</p></li></ul><h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><ul><li>丰富的第三方模块</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h3><ul><li><p>块配置 event,http, server</p></li><li><p>配置项</p><ul><li>格式: 多个值用空格隔开</li><li>单位：通用单位</li><li>变量：少数模块支持，同php</li></ul></li></ul><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p><a href="https://segmentfault.com/a/1190000013267839" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013267839</a></p><ul><li><p>作用: 根据url匹配对应处理规则</p></li><li><p>语法规则</p><ul><li>location [ = | ~ | <del>* | ^</del> ] uri { … }<br>location @name { … }</li></ul></li><li><p>匹配规则</p><ul><li><p>前缀匹配</p><ul><li>= 表示精确匹配</li><li>^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找</li><li>字符串 会相互比较选择匹配度最高的, 一般配合PHP直接使用 location / 转换到php程序</li></ul></li><li><p>正则匹配</p><ul><li>~区分大小写</li><li>~* 不区分大小写</li></ul></li></ul></li></ul><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul><li><p>debug 配置</p></li><li><p>正常运行的配置</p><ul><li>env|env=value定义环境变量 (没怎么用过)</li><li>include,嵌入其他配置, 便于模块化</li><li>pid: master 进程ID的pid文件存放路径</li><li>user username groupname, worker 进程运行的用户以及用户组</li><li>worker_rlimit_nofile limit, 可以打开的最大文件句柄数</li><li>worker_rlimit_sigpending limit, 限制信号队列</li></ul></li><li><p>优化性能配置</p><ul><li>worker_processes number,worker 进程个数</li><li>worker_cpu_affinity cpumask, 绑定worker 进程到cpu内核</li><li>ssl 硬件加速</li><li>系统调用gettimeofday 的评率</li><li>worker 进程优先级</li></ul></li><li><p>时间类配置项</p><ul><li>accept锁相关</li><li>lock 文件路径</li><li>批零建立新连接</li><li>选择时间模型</li><li>每个worker 的最大连接数</li></ul></li></ul><h3 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h3><ul><li>虚拟主机与请求的分发</li><li>文件路径的定义</li><li>内存以及磁盘的分配</li><li>网络连接的设置</li><li>MIME类型的设置</li><li>对客户端请求的限制</li><li>文件操作的优化</li><li>对客户端请求的特殊处理</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      nginx 初步了解
    
    </summary>
    
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="web服务器" scheme="http://yoursite.com/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="http://yoursite.com/2020/01/13/http/"/>
    <id>http://yoursite.com/2020/01/13/http/</id>
    <published>2020-01-13T00:28:17.000Z</published>
    <updated>2020-01-17T07:27:11.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>引用: <a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">https://juejin.im/entry/5981c5df518825359a2b9476</a></p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h3 id="客户端（用户）和服务端（网站）之间请求和应答的标准"><a href="#客户端（用户）和服务端（网站）之间请求和应答的标准" class="headerlink" title="客户端（用户）和服务端（网站）之间请求和应答的标准"></a>客户端（用户）和服务端（网站）之间请求和应答的标准</h3><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><a id="more"></a><h3 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http 1.0"></a>http 1.0</h3><h3 id="http-1-x"><a href="#http-1-x" class="headerlink" title="http 1.x"></a>http 1.x</h3><ul><li><p>改进之处</p><ul><li><p>缓存处理</p></li><li><p>带宽优化及网络连接的使用</p><ul><li>允许只请求资源的某个部分</li></ul></li><li><p>错误通知的管理</p><ul><li>新增了24个错误状态响应码</li></ul></li><li><p>Host头处理</p><ul><li>HTTP1.1的请求消息和响应消息都应支持Host头域</li></ul></li><li><p>长连接</p><ul><li>Connection： keep-alive</li></ul></li></ul></li></ul><h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><ul><li><p>基于google提出的SPDY</p></li><li><p>改进之处</p><ul><li>新的二进制格式</li><li>多路复用(区别于长连接)</li><li>header压缩</li><li>服务端推送</li></ul></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ul><li><p>是什么？</p><ul><li>超文本传输安全协议</li></ul></li><li><p>过程</p><ul><li>HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包</li></ul></li><li><p>区别</p><ul><li>http:运行在TCP之上，所有传输的内容都是明文</li><li>https:运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li></ul></li></ul><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;引用: &lt;a href=&quot;https://juejin.im/entry/5981c5df518825359a2b9476&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/entry/5981c5df518825359a2b9476&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h2&gt;&lt;h3 id=&quot;应用层协议&quot;&gt;&lt;a href=&quot;#应用层协议&quot; class=&quot;headerlink&quot; title=&quot;应用层协议&quot;&gt;&lt;/a&gt;应用层协议&lt;/h3&gt;&lt;h3 id=&quot;客户端（用户）和服务端（网站）之间请求和应答的标准&quot;&gt;&lt;a href=&quot;#客户端（用户）和服务端（网站）之间请求和应答的标准&quot; class=&quot;headerlink&quot; title=&quot;客户端（用户）和服务端（网站）之间请求和应答的标准&quot;&gt;&lt;/a&gt;客户端（用户）和服务端（网站）之间请求和应答的标准&lt;/h3&gt;&lt;h2 id=&quot;发展&quot;&gt;&lt;a href=&quot;#发展&quot; class=&quot;headerlink&quot; title=&quot;发展&quot;&gt;&lt;/a&gt;发展&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>year-summary-2019</title>
    <link href="http://yoursite.com/2020/01/12/year-summary-2019/"/>
    <id>http://yoursite.com/2020/01/12/year-summary-2019/</id>
    <published>2020-01-12T14:14:38.000Z</published>
    <updated>2020-01-21T08:57:09.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作，编程，读书，问题-–2019年总结"><a href="#工作，编程，读书，问题-–2019年总结" class="headerlink" title="工作，编程，读书，问题  –2019年总结"></a>工作，编程，读书，问题  –2019年总结</h1><a id="more"></a><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p><code>整体考虑</code>，<code>主动性</code>，<code>责任感</code>，<code>独当一面</code>，如果用词语概括今年工作的收获的话。工作会伴随我们大半生的时间。进入工作一年半了，自己最大的感受就是如何去做好一份工作。 且不论coding能力的高低，也有很多东西值得体会和去学习。</p><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p><code>编程的理解</code>，今年对编程有了一些新的理解。编程就想是造房子，一个项目就是一个建造一个建筑。大到每个房屋之间怎么配合协调，小到这块装那块瓦怎么放置，都是工程师去设计并实现。当我们去做具体的需要的时候，尽可能的去考虑整体的设计以及兼顾细节的完美，才能编写出艺术品，而不是简单的代码机器的产物。</p><p><code>编程的能力</code>，从编程的能力来说，一些小的总结和一些有待改进</p><ul><li>总结</li></ul><ol><li>解决问题，善于利用google和stackoverflow去快速解决常见的问题</li><li>抓住问题，google和stackoverflow可以快速的找到解决方案,但并不应该只是按照这个上面的copy下来运行一下可以解决问题就完事了。每一个问题都是宝贵的财富，不要避开问题，多看文档多查资料多学习去解决问题，网络可以快速找到解决方案但是方案背后的原理需要去琢磨</li><li>整理归纳，基本功不够扎实，比如经常用到的时间模块，每次使用还是要去现场查资料，没有google开发进度为0。意识到这个问题之后今年开始写博客开始整理了，也算是一个不小的改善了，嘿嘿嘿。</li></ol><ul><li>有待改进：</li></ul><ol><li>多注重技术层次的思考，能够完成基本需求的同时应该去思考技术的本身，提升技术，毕竟技术是安家立命之本。</li></ol><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>今年。读了《python核心编程》,《高性能mysql》,《从小工到专家》.没读完的《编程珠玑》《深入理解nginx》《鸟哥的私房菜》。买了很多技术书籍，看进去的不多。从收获上来说确实有所收获，但是也发现了一些问题。<br>问题:当需要用到一些书中东西的时候，脑袋不是特别的清晰。<br>问题原因: <code>缺少思考与整理</code>，读书不是读小说翻完了就OK了<br>新的认识:书籍是作者按照他的思路与思维模式去编写的知识载体，对于自己来说，我们拥有自己的知识网络，我们需要理解去归纳到自己的知识网络。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>遇到一个问题，<code>从日常需求来说其实都比较杂乱，经常做了之后没有足够的满足感和成就感。具体的实际影响就是比较累而且收获不大</code>。<br>深入思考了这个问题很久，我的解决方案</p><ol><li><code>心态</code>，作为一个刚进入工作的年轻人，应该去感激每一个机会去学习去积累</li><li><code>技术的思考</code>，，当你做简单的事情的时候，有没有考虑你是否是站在巨人的肩膀上，才显得特别轻松。当你用bootstrap的时候有没有考虑过为什么这个框架这么受欢迎？他是怎么实现的？为什么laravel比TP好用？为什么选择mysql数据库？简单的东西需要去思考去研究。</li><li><code>业务的思考</code>，当新的需要提出的时候，应该是考虑此需求背后的具体的问题点是什么，从工程师的角度是否有更好的方式去解决，而不是只是想一个代码机器去执行PM的需求文档里面的流程。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工作，编程，读书，问题-–2019年总结&quot;&gt;&lt;a href=&quot;#工作，编程，读书，问题-–2019年总结&quot; class=&quot;headerlink&quot; title=&quot;工作，编程，读书，问题  –2019年总结&quot;&gt;&lt;/a&gt;工作，编程，读书，问题  –2019年总结&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="summary" scheme="http://yoursite.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>npm</title>
    <link href="http://yoursite.com/2020/01/09/npm/"/>
    <id>http://yoursite.com/2020/01/09/npm/</id>
    <published>2020-01-09T00:37:06.000Z</published>
    <updated>2020-01-17T07:27:40.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><h3 id="全称-Node-Package-Manager，即node包管理器"><a href="#全称-Node-Package-Manager，即node包管理器" class="headerlink" title="全称 Node Package Manager，即node包管理器"></a>全称 Node Package Manager，即node包管理器</h3><p><a href="https://zh.wikipedia.org/wiki/Npm" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Npm</a></p><h2 id="常用功能与命令"><a href="#常用功能与命令" class="headerlink" title="常用功能与命令"></a>常用功能与命令</h2><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>npm install</p><ul><li><p>不加后缀直接安装，如果node_modules存在，就不再重新安装了，即使有新，也是如此, -f 强制重新安装</p></li><li><p>package.json与package-lock.json</p><p>参见：<a href="https://juejin.im/post/5d40f9a4e51d45620821ce30" target="_blank" rel="noopener">https://juejin.im/post/5d40f9a4e51d45620821ce30</a></p><ul><li><p>是什么？</p><ul><li>配置文件,锁定安装时的包的版本号</li></ul></li><li><p>配合使用</p><ul><li>如果没有lockfile, npm i会生成一个</li><li>两者兼容，根据localfile 下载</li><li>两者不兼容，会根据package.json下载，并更新lockfile</li></ul></li></ul></li><li><p>npm install <package name>  安装模块的特定版本 use @</p></li></ul></li><li><p>npm ci</p><ul><li>适合安装干净依赖的情况</li><li>快，更严格</li><li>必须有lockfile</li><li>不会修改文件</li></ul></li><li><p>install &amp;&amp; ci</p><p>npm install 读取 package.json 创建依赖项列表，并使用 package-lock.json 来通知要安装这些依赖项的哪个版本。如果某个依赖项在 package.json 中，但是不在 package-lock.json 中，运行 npm install 会将这个依赖项的确定版本更新到 package-lock.json 中。<br>npm ci 是根据 package-lock.json 去安装确定的依赖，package.json 只是用来验证是不是有不匹配的版本，假设 package-lock.json 中存在一个确定版本的依赖 A，如果 package.json 中不存在依赖 A 或者依赖 A 版本和 lock 中不兼容，npm ci 就会报错。</p></li></ul><h3 id="查看包版本"><a href="#查看包版本" class="headerlink" title="查看包版本"></a>查看包版本</h3><ul><li><p>npm list</p><ul><li>默认当前项目下的所有模块以及依赖</li><li>-g 全局</li><li>packagename 查看单独模块</li></ul></li></ul><h3 id="npm-脚本"><a href="#npm-脚本" class="headerlink" title="npm 脚本"></a>npm 脚本</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;npm&quot;&gt;&lt;a href=&quot;#npm&quot; class=&quot;headerlink&quot; title=&quot;npm&quot;&gt;&lt;/a&gt;npm&lt;/h1&gt;&lt;h2 id=&quot;是什么？&quot;&gt;&lt;a href=&quot;#是什么？&quot; class=&quot;headerlink&quot; title=&quot;是什么？&quot;&gt;&lt;/a&gt;是什么？&lt;/h2&gt;&lt;h3 id=&quot;全称-Node-Package-Manager，即node包管理器&quot;&gt;&lt;a href=&quot;#全称-Node-Package-Manager，即node包管理器&quot; class=&quot;headerlink&quot; title=&quot;全称 Node Package Manager，即node包管理器&quot;&gt;&lt;/a&gt;全称 Node Package Manager，即node包管理器&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Npm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/Npm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;常用功能与命令&quot;&gt;&lt;a href=&quot;#常用功能与命令&quot; class=&quot;headerlink&quot; title=&quot;常用功能与命令&quot;&gt;&lt;/a&gt;常用功能与命令&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql-explain</title>
    <link href="http://yoursite.com/2019/12/19/mysql-explain/"/>
    <id>http://yoursite.com/2019/12/19/mysql-explain/</id>
    <published>2019-12-19T15:04:57.000Z</published>
    <updated>2020-01-17T07:27:29.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-explain"><a href="#mysql-explain" class="headerlink" title="mysql explain"></a>mysql explain</h1><h2 id="作用：sql查询如何执行，近似结果"><a href="#作用：sql查询如何执行，近似结果" class="headerlink" title="作用：sql查询如何执行，近似结果"></a>作用：sql查询如何执行，近似结果</h2><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><a id="more"></a><h3 id="explain-extend"><a href="#explain-extend" class="headerlink" title="explain extend"></a>explain extend</h3><h3 id="explain-partitions"><a href="#explain-partitions" class="headerlink" title="explain partitions"></a>explain partitions</h3><h2 id="主要行解释"><a href="#主要行解释" class="headerlink" title="主要行解释"></a>主要行解释</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul><li><p>编号，</p><p>标识select 所属行，id越大越先执行，id相同顺序执行</p></li></ul><h3 id="select-type"><a href="#select-type" class="headerlink" title="select type"></a>select type</h3><ul><li>显示对应行是简单还是复杂查询</li></ul><h3 id="type-访问类型"><a href="#type-访问类型" class="headerlink" title="type(访问类型)"></a>type(访问类型)</h3><ul><li><p>NULL</p></li><li><p>const、system</p></li><li><p>eq_ref</p></li><li><p>ref</p></li><li><p>range</p></li><li><p>index</p><ul><li>全表扫描，按照索引</li></ul></li><li><p>ALL</p><ul><li>全表扫描，按行</li></ul></li></ul><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><ul><li>显示正在访问的表</li></ul><h3 id="ken-len"><a href="#ken-len" class="headerlink" title="ken_len"></a>ken_len</h3><ul><li>索引使用字节数</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h3 id="row"><a href="#row" class="headerlink" title="row"></a>row</h3><ul><li>估计读取行数</li></ul><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>参考：<a href="https://www.cnblogs.com/kerrycode/p/9909093.html" target="_blank" rel="noopener">https://www.cnblogs.com/kerrycode/p/9909093.html</a></p><ul><li>Using temporary</li><li>Using filesort</li><li>Using Index</li><li>Using Index Condition</li><li>Using where</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql-explain&quot;&gt;&lt;a href=&quot;#mysql-explain&quot; class=&quot;headerlink&quot; title=&quot;mysql explain&quot;&gt;&lt;/a&gt;mysql explain&lt;/h1&gt;&lt;h2 id=&quot;作用：sql查询如何执行，近似结果&quot;&gt;&lt;a href=&quot;#作用：sql查询如何执行，近似结果&quot; class=&quot;headerlink&quot; title=&quot;作用：sql查询如何执行，近似结果&quot;&gt;&lt;/a&gt;作用：sql查询如何执行，近似结果&lt;/h2&gt;&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;h2 id=&quot;相关&quot;&gt;&lt;a href=&quot;#相关&quot; class=&quot;headerlink&quot; title=&quot;相关&quot;&gt;&lt;/a&gt;相关&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>shell-script</title>
    <link href="http://yoursite.com/2019/12/12/shell-script/"/>
    <id>http://yoursite.com/2019/12/12/shell-script/</id>
    <published>2019-12-12T11:10:38.000Z</published>
    <updated>2020-01-17T07:27:49.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h1><h2 id="作用：处理用户和系统的交互"><a href="#作用：处理用户和系统的交互" class="headerlink" title="作用：处理用户和系统的交互"></a>作用：处理用户和系统的交互</h2><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><p>详细请看<a href="https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1</a></p><h2 id="相关拓展"><a href="#相关拓展" class="headerlink" title="相关拓展"></a>相关拓展</h2><a id="more"></a><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>原文:<a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/11/bash-set.html</a></p><ul><li><p>问题：</p><ul><li>目前shell 遇到错误不会自动暂停，会继续向下执行，这个其他python之类程序有很大不同，很可能产生和预期不一样的结果</li></ul></li><li><p>解决:set command用来定制环境</p><ul><li><p>-u 遇到不存在的变量报错(同-o nounset)</p></li><li><p>错误处理</p><ul><li><p>command || exit 1</p></li><li><p>-e:发生错误，就终止执行(同-o errexit)</p></li><li><p>特殊对于管道命令</p><ul><li>特殊性：Bash 会把最后一个子命令的返回值，作为整个命令的返回值</li><li>set -o pipefail:个人理解是把管道内部命令抛出去然后外部-e 会捕获，所以对于管道内部其实还是会继续执行操作</li></ul></li></ul></li><li><p>-x 输出详细输入输出(同-o xtrace)</p></li><li><p>汇总:</p><ul><li>shell 内部：set -euxo pipefail（推荐）</li><li>执行时：bash -euxo pipefail xxx.sh</li></ul></li></ul></li></ul><h3 id="ssh交互"><a href="#ssh交互" class="headerlink" title="ssh交互"></a>ssh交互</h3><ul><li><p>简介:ssh 不单可以登录，可以直接执行相关命令ssh <a href="mailto:nick@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">nick@xxx.xxx.xxx.xxx</a> “df -h”</p></li><li><p>shell  中需要与remote server 交互</p><ul><li><p>简单命令</p><ul><li>可以直接放在后面,使用引号, 例如ssh  $remote_host “mysqldump -uxxx-pxxx xxx”</li><li>缺点：(不能传递变量)</li></ul></li><li><p>复杂命令</p><ul><li>想要实现复杂的命令,可以写在外部脚本中</li><li>eg:ssh <a href="mailto:nick@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">nick@xxx.xxx.xxx.xxx</a> ‘bash -s’ &lt; test.sh var1 var2</li></ul></li></ul></li></ul><h3 id="相关操作符"><a href="#相关操作符" class="headerlink" title="相关操作符"></a>相关操作符</h3><ul><li><a href="https://blog.csdn.net/x1269778817/article/details/46535729" target="_blank" rel="noopener">https://blog.csdn.net/x1269778817/article/details/46535729</a></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shell-脚本&quot;&gt;&lt;a href=&quot;#shell-脚本&quot; class=&quot;headerlink&quot; title=&quot;shell 脚本&quot;&gt;&lt;/a&gt;shell 脚本&lt;/h1&gt;&lt;h2 id=&quot;作用：处理用户和系统的交互&quot;&gt;&lt;a href=&quot;#作用：处理用户和系统的交互&quot; class=&quot;headerlink&quot; title=&quot;作用：处理用户和系统的交互&quot;&gt;&lt;/a&gt;作用：处理用户和系统的交互&lt;/h2&gt;&lt;h2 id=&quot;语法基础&quot;&gt;&lt;a href=&quot;#语法基础&quot; class=&quot;headerlink&quot; title=&quot;语法基础&quot;&gt;&lt;/a&gt;语法基础&lt;/h2&gt;&lt;p&gt;详细请看&lt;a href=&quot;https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关拓展&quot;&gt;&lt;a href=&quot;#相关拓展&quot; class=&quot;headerlink&quot; title=&quot;相关拓展&quot;&gt;&lt;/a&gt;相关拓展&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql-lock</title>
    <link href="http://yoursite.com/2019/12/09/mysql-lock/"/>
    <id>http://yoursite.com/2019/12/09/mysql-lock/</id>
    <published>2019-12-09T15:58:44.000Z</published>
    <updated>2020-01-17T07:27:36.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-锁机制"><a href="#mysql-锁机制" class="headerlink" title="mysql 锁机制"></a>mysql 锁机制</h1><p><a href="https://learnku.com/articles/28772#c812c1" target="_blank" rel="noopener">https://learnku.com/articles/28772#c812c1</a> 锁机制</p><h2 id="作用：解决并发访问"><a href="#作用：解决并发访问" class="headerlink" title="作用：解决并发访问"></a>作用：解决并发访问</h2><h2 id="所处的处置：一般-表锁在mysql-server层，行锁在索引层"><a href="#所处的处置：一般-表锁在mysql-server层，行锁在索引层" class="headerlink" title="所处的处置：一般,表锁在mysql server层，行锁在索引层"></a>所处的处置：一般,表锁在mysql server层，行锁在索引层</h2><a id="more"></a><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><ul><li><p>表锁</p></li><li><p>行锁</p><ul><li>实现方式：索引加锁</li></ul></li><li><p>页锁</p></li></ul><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul><li><p>写锁</p><ul><li>for update. 比读锁有更高的优先级</li></ul></li><li><p>读锁</p><ul><li>lock in share mode, 普通select innodb不会有任何锁</li></ul></li></ul><h3 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h3><ul><li><p>记录锁</p></li><li><p>间隙锁</p></li><li><p>next-key锁</p></li><li><p>意向锁</p><ul><li>是一个标记锁，为了实现表锁和行锁不同的锁粒度</li></ul></li><li><p>插入意向锁</p></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql-锁机制&quot;&gt;&lt;a href=&quot;#mysql-锁机制&quot; class=&quot;headerlink&quot; title=&quot;mysql 锁机制&quot;&gt;&lt;/a&gt;mysql 锁机制&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://learnku.com/articles/28772#c812c1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learnku.com/articles/28772#c812c1&lt;/a&gt; 锁机制&lt;/p&gt;
&lt;h2 id=&quot;作用：解决并发访问&quot;&gt;&lt;a href=&quot;#作用：解决并发访问&quot; class=&quot;headerlink&quot; title=&quot;作用：解决并发访问&quot;&gt;&lt;/a&gt;作用：解决并发访问&lt;/h2&gt;&lt;h2 id=&quot;所处的处置：一般-表锁在mysql-server层，行锁在索引层&quot;&gt;&lt;a href=&quot;#所处的处置：一般-表锁在mysql-server层，行锁在索引层&quot; class=&quot;headerlink&quot; title=&quot;所处的处置：一般,表锁在mysql server层，行锁在索引层&quot;&gt;&lt;/a&gt;所处的处置：一般,表锁在mysql server层，行锁在索引层&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="lock" scheme="http://yoursite.com/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>string-decode</title>
    <link href="http://yoursite.com/2019/12/09/string-decode/"/>
    <id>http://yoursite.com/2019/12/09/string-decode/</id>
    <published>2019-12-09T15:13:12.000Z</published>
    <updated>2020-01-20T07:36:50.578Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/string-encode-decode.png" alt="avatar"></p><h1 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h1><p>发展与概述文章<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p><h2 id="作用-使机器识别不同的字符串"><a href="#作用-使机器识别不同的字符串" class="headerlink" title="作用:使机器识别不同的字符串"></a>作用:使机器识别不同的字符串</h2><h2 id="编码分类与发展"><a href="#编码分类与发展" class="headerlink" title="编码分类与发展"></a>编码分类与发展</h2><h3 id="编码发展"><a href="#编码发展" class="headerlink" title="编码发展"></a>编码发展</h3><ul><li><p>ASCII</p><ul><li>英语字符和二进制位对应</li></ul></li><li><p>unicode</p><ul><li>概述:字符集,所有的字符对应二进制位，但是没有规定这个二进制代码应该如何存储</li><li>优点:实现了统一 的编码</li><li>缺点:如何存储编码?兼容之后的资源浪费？</li></ul></li><li><p>utf-8</p><ul><li><p>概述:针对Unicode的可变长度字符编码实现，使用1~4个字节表示一个符号</p></li><li><p>特点:</p><ul><li>兼容ASCII. ASCII是UTF-8的一个子集</li></ul></li></ul></li><li><p>UCS-2和UCS-4:文字和代码点之间的对应关系</p></li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul><li>unicode 与utf-8: utf-8是Unicode的一种实现方式,从计算机工作方式来说一般在utf-8是用来存储和传输，unicode 一般用来转换</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="python2-编码问题"><a href="#python2-编码问题" class="headerlink" title="python2 编码问题"></a>python2 编码问题</h3><p>细节请看：<a href="https://www.jianshu.com/p/58d5f64813dc" target="_blank" rel="noopener">https://www.jianshu.com/p/58d5f64813dc</a></p><ul><li><p>type:str与unicode</p><ul><li>str 是Unicode经过编码的字节</li><li>真正的字符串</li></ul></li><li><p>类型转换</p><ul><li>2种类型的字符串都提供了 encode 和 decode 方法，通过类型转换解决问题</li></ul></li><li><p>坑</p><ul><li>编码、解码:python 会隐式地进行，默认采用 sys.setdefaultencoding()(一般是ascii)</li><li>标准输出,ptint会按照 sys.stdout.encoding 来给 unicode 编码，交给操作系统输出</li></ul></li></ul><h3 id="python去除文本中的emoji"><a href="#python去除文本中的emoji" class="headerlink" title="python去除文本中的emoji"></a>python去除文本中的emoji</h3><ul><li>问题描述: mysql utf8 不兼容emoji(utf8mb4 兼容),如何remove?</li><li>思路: 找到unicode中四字节字符删除</li><li>具体:<figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">highpoints = re.compile(u&apos;[\U00010000-\U0010ffff]&apos;) # UCS-4</span><br><span class="line">highpoints = re.compile(u&apos;[\uD800-\uDBFF][\uDC00-\uDFFF]&apos;) # UCS-2</span><br></pre></td></tr></table></figure></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://q4b6m25wx.bkt.clouddn.com/xmind/string-encode-decode.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;字符串编码&quot;&gt;&lt;a href=&quot;#字符串编码&quot; class=&quot;heade
      
    
    </summary>
    
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>python-datetime</title>
    <link href="http://yoursite.com/2019/12/01/python-datetime/"/>
    <id>http://yoursite.com/2019/12/01/python-datetime/</id>
    <published>2019-12-01T14:46:31.000Z</published>
    <updated>2020-01-17T07:27:42.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-时间和日期"><a href="#python-时间和日期" class="headerlink" title="python 时间和日期"></a>python 时间和日期</h1><h2 id="时间字符串格式化"><a href="#时间字符串格式化" class="headerlink" title="时间字符串格式化"></a>时间字符串格式化</h2><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior</a></p><h3 id="时间元组转换成字符串-strptime"><a href="#时间元组转换成字符串-strptime" class="headerlink" title="时间元组转换成字符串: strptime(),"></a>时间元组转换成字符串: strptime(),</h3><a id="more"></a><h3 id="字符串转换成时间元组-strftime"><a href="#字符串转换成时间元组-strftime" class="headerlink" title="字符串转换成时间元组:strftime(),"></a>字符串转换成时间元组:strftime(),</h3><h2 id="时间换算"><a href="#时间换算" class="headerlink" title="时间换算"></a>时间换算</h2><h3 id="主要是datetime-timedelta"><a href="#主要是datetime-timedelta" class="headerlink" title="主要是datetime.timedelta()"></a>主要是datetime.timedelta()</h3><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/datetime.html</a></p><ul><li><p>有效类型</p><ul><li>date</li><li>time</li><li>datetime</li><li>timedelta</li><li>tzinfo</li><li>timezone</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-时间和日期&quot;&gt;&lt;a href=&quot;#python-时间和日期&quot; class=&quot;headerlink&quot; title=&quot;python 时间和日期&quot;&gt;&lt;/a&gt;python 时间和日期&lt;/h1&gt;&lt;h2 id=&quot;时间字符串格式化&quot;&gt;&lt;a href=&quot;#时间字符串格式化&quot; class=&quot;headerlink&quot; title=&quot;时间字符串格式化&quot;&gt;&lt;/a&gt;时间字符串格式化&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;时间元组转换成字符串-strptime&quot;&gt;&lt;a href=&quot;#时间元组转换成字符串-strptime&quot; class=&quot;headerlink&quot; title=&quot;时间元组转换成字符串: strptime(),&quot;&gt;&lt;/a&gt;时间元组转换成字符串: strptime(),&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux-file-permission</title>
    <link href="http://yoursite.com/2019/11/24/linux-file-permission/"/>
    <id>http://yoursite.com/2019/11/24/linux-file-permission/</id>
    <published>2019-11-24T15:56:57.000Z</published>
    <updated>2020-01-17T07:27:20.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-文件权限"><a href="#linux-文件权限" class="headerlink" title="linux 文件权限"></a>linux 文件权限</h1><h2 id="文件权限：每个文件可以针对每个用户具有不同的权限"><a href="#文件权限：每个文件可以针对每个用户具有不同的权限" class="headerlink" title="文件权限：每个文件可以针对每个用户具有不同的权限"></a>文件权限：每个文件可以针对每个用户具有不同的权限</h2><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="为什么要有这么细致的分级？"><a href="#为什么要有这么细致的分级？" class="headerlink" title="为什么要有这么细致的分级？"></a>为什么要有这么细致的分级？</h3><ul><li>安全防护，因为linux多用户，多任务的环境。每个用户的权限隐私很重要</li></ul><h3 id="文件用户身份"><a href="#文件用户身份" class="headerlink" title="文件用户身份"></a>文件用户身份</h3><ul><li><p>own/group/other</p><a id="more"></a><h3 id="权限等级与意义"><a href="#权限等级与意义" class="headerlink" title="权限等级与意义"></a>权限等级与意义</h3></li><li><p>read</p><ul><li>对文件: 读取文件</li><li>对目录:读取该目录结构</li></ul></li><li><p>write</p><ul><li>对文件: 包括编辑新增等，但是不包括删除, 那么怎么才能删除文件呢？</li><li>对目录:更改目录结构的，包括增删改，注意删除的权限在这里</li></ul></li><li><p>execute</p><ul><li>对文件:可执行</li><li>对目录:注意，代表用户是否可以进入该目录，区分与r权限</li></ul></li></ul><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><h3 id="定义-一个文件拥有的属性"><a href="#定义-一个文件拥有的属性" class="headerlink" title="定义:一个文件拥有的属性"></a>定义:一个文件拥有的属性</h3><h3 id="内容包括-权限，连接，所有者，用户组，文件容量，修改日期，文件名"><a href="#内容包括-权限，连接，所有者，用户组，文件容量，修改日期，文件名" class="headerlink" title="内容包括:权限，连接，所有者，用户组，文件容量，修改日期，文件名"></a>内容包括:权限，连接，所有者，用户组，文件容量，修改日期，文件名</h3><h3 id="command-chgrp-chown-chmod"><a href="#command-chgrp-chown-chmod" class="headerlink" title="command:chgrp/chown/chmod"></a>command:chgrp/chown/chmod</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;linux-文件权限&quot;&gt;&lt;a href=&quot;#linux-文件权限&quot; class=&quot;headerlink&quot; title=&quot;linux 文件权限&quot;&gt;&lt;/a&gt;linux 文件权限&lt;/h1&gt;&lt;h2 id=&quot;文件权限：每个文件可以针对每个用户具有不同的权限&quot;&gt;&lt;a href=&quot;#文件权限：每个文件可以针对每个用户具有不同的权限&quot; class=&quot;headerlink&quot; title=&quot;文件权限：每个文件可以针对每个用户具有不同的权限&quot;&gt;&lt;/a&gt;文件权限：每个文件可以针对每个用户具有不同的权限&lt;/h2&gt;&lt;h2 id=&quot;用户和用户组&quot;&gt;&lt;a href=&quot;#用户和用户组&quot; class=&quot;headerlink&quot; title=&quot;用户和用户组&quot;&gt;&lt;/a&gt;用户和用户组&lt;/h2&gt;&lt;h3 id=&quot;为什么要有这么细致的分级？&quot;&gt;&lt;a href=&quot;#为什么要有这么细致的分级？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有这么细致的分级？&quot;&gt;&lt;/a&gt;为什么要有这么细致的分级？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;安全防护，因为linux多用户，多任务的环境。每个用户的权限隐私很重要&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;文件用户身份&quot;&gt;&lt;a href=&quot;#文件用户身份&quot; class=&quot;headerlink&quot; title=&quot;文件用户身份&quot;&gt;&lt;/a&gt;文件用户身份&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;own/group/other&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest 与 js</title>
    <link href="http://yoursite.com/2019/11/22/XMLHttpRequest/"/>
    <id>http://yoursite.com/2019/11/22/XMLHttpRequest/</id>
    <published>2019-11-21T16:53:02.000Z</published>
    <updated>2020-01-17T07:27:55.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XMLHttpRequest是什么？"><a href="#XMLHttpRequest是什么？" class="headerlink" title="XMLHttpRequest是什么？"></a>XMLHttpRequest是什么？</h3><p>XMLHttpRequest是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。<br>关联: 有了XMLHttpRequest对象。ajax操作因此得以诞生。所以在这里 ajax，是一种技术方案</p><h3 id="js-ajax发送请求"><a href="#js-ajax发送请求" class="headerlink" title="js ajax发送请求"></a>js ajax发送请求</h3><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// get</span><br><span class="line">var httpRequest = new XMLHttpRequest();//第一步：建立所需的对象</span><br><span class="line">httpRequest.open(&apos;GET&apos;, &apos;url&apos;, true);//第二步：打开连接  将请求参数写在url中  ps:&quot;./Ptest.php?name=test&amp;nameone=testone&quot;</span><br><span class="line">httpRequest.send();//第三步：发送请求  将请求参数写在URL中</span><br><span class="line">httpRequest.onreadystatechange = function () &#123;</span><br><span class="line">    if (httpRequest.readyState == 4 &amp;&amp; httpRequest.status == 200) &#123;</span><br><span class="line">        var json = httpRequest.responseText;</span><br><span class="line">        console.log(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">// post</span><br><span class="line">var httpRequest = new XMLHttpRequest();//第一步：创建需要的对象</span><br><span class="line">httpRequest.open(&apos;POST&apos;, &apos;url&apos;, true); //第二步：打开连接</span><br><span class="line">httpRequest.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//设置请求头 注：post方式必须设置请求头（在建立连接后设置请求头）</span><br><span class="line">httpRequest.send(&apos;name=teswe&amp;ee=ef&apos;);//发送请求 将情头体写在send中</span><br><span class="line">httpRequest.onreadystatechange = function () &#123;//请求后的回调接口，可将请求成功后要执行的程序写在其中</span><br><span class="line">    if (httpRequest.readyState == 4 &amp;&amp; httpRequest.status == 200) &#123;//验证请求是否发送成功</span><br><span class="line">        var json = httpRequest.responseText;//获取到服务端返回的数据</span><br><span class="line">        console.log(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="js-发送非ajax请求"><a href="#js-发送非ajax请求" class="headerlink" title="js 发送非ajax请求"></a>js 发送非ajax请求</h3><p>get 请求就不必多说了。 <code>windows.location.href = &#39;url&#39;;</code><br>post, 我是模拟表单进行提交post请求</p><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var temp = document.createElement(&quot;form&quot;);</span><br><span class="line">temp.action = &apos;%s&apos;;</span><br><span class="line">temp.method = &quot;post&quot;;</span><br><span class="line">temp.style.display = &quot;none&quot;;</span><br><span class="line">form_data = &#123;</span><br><span class="line">    &apos;action&apos;: &apos;applycoupon&apos;,</span><br><span class="line">    &apos;couponcode&apos;: &apos;%s&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">for(var key in form_data)&#123;</span><br><span class="line">    var opt = document.createElement(&quot;textarea&quot;);</span><br><span class="line">    opt.name = key;</span><br><span class="line">    opt.value = form_data[key];</span><br><span class="line">    temp.appendChild(opt);</span><br><span class="line">&#125;</span><br><span class="line">document.body.appendChild(temp);</span><br><span class="line">temp.submit();</span><br></pre></td></tr></table></figure><p>这里主要理解XMLHttpRequest是什么，具体代码细节不细说了，请参考</p><blockquote><p><a href="https://segmentfault.com/a/1190000004322487#articleHeader18" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004322487#articleHeader18</a><br><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XMLHttpRequest是什么？&quot;&gt;&lt;a href=&quot;#XMLHttpRequest是什么？&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest是什么？&quot;&gt;&lt;/a&gt;XMLHttpRequest是什么？&lt;/h3&gt;&lt;p&gt;XMLHtt
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>regular-expression-note</title>
    <link href="http://yoursite.com/2019/11/17/regular-expression-note/"/>
    <id>http://yoursite.com/2019/11/17/regular-expression-note/</id>
    <published>2019-11-17T15:30:14.000Z</published>
    <updated>2020-01-17T07:27:45.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h4><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p><a id="more"></a><p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。<br>(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p><p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。</p><p>下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请详细分析表达式(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)，这个表达式最能表现零宽断言的真正用途。</span><br><span class="line">一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)。</span><br></pre></td></tr></table></figure><h4 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</span><br><span class="line">\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。</span><br><span class="line"></span><br><span class="line">零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d&#123;3&#125;(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</span><br><span class="line"></span><br><span class="line">同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d&#123;7&#125;匹配前面不是小写字母的七位数字。</span><br></pre></td></tr></table></figure><h4 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</span><br><span class="line"></span><br><span class="line">有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</span><br><span class="line"></span><br><span class="line">a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</span><br></pre></td></tr></table></figure><h4 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h4><p>使用小括号指定一个子表达式后，<code>匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理</code>。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p><p>呃……其实,组号分配还不像我刚说得那么简单：</p><p>分组0对应整个正则表达式<br>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号<br>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．<br>后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：</p><p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。</p><p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。<br><img src="evernotecid://A7FC8235-39E4-4893-9D89-39960F38D08F/wwwevernotecom/187238225/ENResource/p138" alt="3b7159b45fc96abe1c22fd55c0f98929.png"><br>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？<br>(原文链接)[<a href="https://deerchao.net/tutorials/regex/regex.htm#negation" target="_blank" rel="noopener">原文链接</a>]</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;零宽断言&quot;&gt;&lt;a href=&quot;#零宽断言&quot; class=&quot;headerlink&quot; title=&quot;零宽断言&quot;&gt;&lt;/a&gt;零宽断言&lt;/h4&gt;&lt;p&gt;接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git note</title>
    <link href="http://yoursite.com/2019/11/17/git-note/"/>
    <id>http://yoursite.com/2019/11/17/git-note/</id>
    <published>2019-11-17T10:11:23.000Z</published>
    <updated>2020-01-17T07:26:56.751Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本地多个-remote-配置（同步推送到线上服务器）"><a href="#本地多个-remote-配置（同步推送到线上服务器）" class="headerlink" title="本地多个 remote 配置（同步推送到线上服务器）"></a>本地多个 remote 配置（同步推送到线上服务器）</h4><ol><li>远程 git库初始化，并配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git config receive.denyCurrentBranch updateInstead</span><br></pre></td></tr></table></figure></li><li>本地添加远程地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add productionServer ssh://ubuntu@xxx.xxx.xxx.xxx/usr/share/nginx/git_dir</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Git-Config中receive-denyCurrentBranch做了什么"><a href="#Git-Config中receive-denyCurrentBranch做了什么" class="headerlink" title="Git Config中receive.denyCurrentBranch做了什么?"></a>Git Config中receive.denyCurrentBranch做了什么?</h4>这个config是决定 当你Push到一个非bare的远程库的正处于切换状态下分支时的行为。</li></ol><p>设置为true或refuse时，会拒绝你的push并且发出几行警告消息<br>设置为warn时，会接受你的push并且发出几行警告消息<br>设置为false或ignore时会接受你的push且不发出警告</p><p>后两种虽然接受了push,但并没有直接反映在工作目录(working tree)上，你需要输入git reset –hard, 或者切换到其他分支再切换回来，才能刷新文件</p><p>设置为updateInstead时，会接受push并直接更新工作目录,但如果工作目录相对HEAD指针有更新，则会拒绝push</p><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><p><code>git checkout -- file</code>，没有–，就变成了“切换到另一个分支”的命令<br>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：<br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。<br>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作</p><blockquote><p>总之，就是让这个文件回到最近一次git commit或git add时的状态</p></blockquote><p><code>git checkout --orphan &lt;new_branch&gt;</code><br>假如你的某个分支上，积累了无数次的提交，你也懒得去打理，打印出的log也让你无力吐槽，那么这个命令将是你的神器，它会基于当前所在分支新建一个赤裸裸的分支，没有任何的提交历史，但是当前分支的内容一一俱全。新建的分支，严格意义上说，还不是一个分支，因为HEAD指向的引用中没有commit值，只有在进行一次提交后，它才算得上真正的分支。</p><p><code>git checkout &lt;name&gt; 切换分支：</code></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>写法：git reset [–hard|soft|mixed|merge|keep] [<commit>或HEAD]<br>功能：命令既可以回退版本，也可以把暂存区的修改回退到工作区<br>原理：将当前的分支重设（reset）到指定的<commit>或者HEAD（默认，如果不显示指定commit，默认是HEAD，即<br>最新的一次提交）<br>–hard：重设（reset） index和working directory，自从<commit>以来在working directory中的任何改变都﻿被丢弃，并把HEAD指向<commit>。<br>–soft：index和working directory中的内容不作任何改变，仅仅把HEAD指向<commit>。这个模式的效果是，执行完毕后，自从<commit>以来的所有改变都会显示在git status的”Changes to be committed”中。<br>–mixed:仅reset index，但是不reset working directory。</p><p>###git  checkout 与git reset区别<br>git checkout是把<code>工作区文件</code>回到最近一次git commit<code>或</code>git add时的状态<br>git reset 是使用<code>仓库区更新工作区和暂存区</code></p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>??? 储存在当前分支还是针对所有分支都可见<br>切换分支时必须commit your changes or stash them before you switch branches.<br>保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save ‘message…’可以添加一些注释</p><p>git stash list<br>显示保存进度的列表。也就意味着，git stash命令可以多次执行。</p><p><code>git stash pop</code> [–index] [stash_id]<br>git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。<br><code>git stash pop --index</code> 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）<br>git stash pop stash@{1}恢复指定的进度到工作区。stash_id是通过git stash list命令得到的<br>通过git stash pop命令恢复进度后，会删除当前进度。<br>git stash apply [–index] [stash_id]<br>除了不删除恢复的进度之外，其余和git stash pop 命令一样。</p><p>git stash drop [stash_id]<br>删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。</p><p>git stash clear<br>删除所有存储的进度。</p><h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><p>git rebase master 待实践</p><h4 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h4><p>简单用法：<br>git cherry-pick <commit id><br>注意：当执行完 cherry-pick 以后，将会生成一个新的提交；这个新的提交的哈希值和原来的不同，但标识名一样；</p><h4 id="git-log-and-git-reflog"><a href="#git-log-and-git-reflog" class="headerlink" title="git log and git reflog"></a>git log and git reflog</h4><p><a href="http://wjp2013.github.io/tool/git-reflog-git-log-git-cherry-pick/" target="_blank" rel="noopener">http://wjp2013.github.io/tool/git-reflog-git-log-git-cherry-pick/</a></p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><p>删除远端分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin -d login-test</span><br></pre></td></tr></table></figure><p>先查看远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -ｒ</span><br></pre></td></tr></table></figure><p>查看所有分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h4 id="git-pull与-rebase"><a href="#git-pull与-rebase" class="headerlink" title="git pull与 rebase"></a>git pull与 rebase</h4><p>今天<br>git pull origin master:master –rebase<br>发生了错误<br>! [rejected] (non-fast-forward)</p><p>一般non-fast-forward 这个错误是发生在push的时候和远程节点不对应，但是今天Git pull 也发生了问题，但是奇怪的是<br>git pull origin master –rebase<br>却可以正常运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本地多个-remote-配置（同步推送到线上服务器）&quot;&gt;&lt;a href=&quot;#本地多个-remote-配置（同步推送到线上服务器）&quot; class=&quot;headerlink&quot; title=&quot;本地多个 remote 配置（同步推送到线上服务器）&quot;&gt;&lt;/a&gt;本地多个 remote 配置（同步推送到线上服务器）&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;远程 git库初始化，并配置&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config receive.denyCurrentBranch updateInstead&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;本地添加远程地址&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add productionServer ssh://ubuntu@xxx.xxx.xxx.xxx/usr/share/nginx/git_dir&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
