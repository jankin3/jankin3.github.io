<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Those who cannot remember the past are condemned to repeat it.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-16T09:29:18.884Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jankin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>oauth</title>
    <link href="http://yoursite.com/2020/02/16/oauth/"/>
    <id>http://yoursite.com/2020/02/16/oauth/</id>
    <published>2020-02-16T06:21:26.000Z</published>
    <updated>2020-02-16T09:29:18.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/oauth.png" alt="avatar"></p><h1 id="oauth"><a href="#oauth" class="headerlink" title="oauth"></a>oauth</h1><h2 id="oauth是什么？"><a href="#oauth是什么？" class="headerlink" title="oauth是什么？"></a>oauth是什么？</h2><h3 id="一个开放标准，允许用户-无需提供将用户名和密码-让第三方应用访问该用户在某一网站上存储的私密的资源"><a href="#一个开放标准，允许用户-无需提供将用户名和密码-让第三方应用访问该用户在某一网站上存储的私密的资源" class="headerlink" title="一个开放标准，允许用户(无需提供将用户名和密码)让第三方应用访问该用户在某一网站上存储的私密的资源"></a>一个开放标准，允许用户(无需提供将用户名和密码)让第三方应用访问该用户在某一网站上存储的私密的资源</h3><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><a id="more"></a><p>参考：<a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p><h3 id="提供一个token令牌"><a href="#提供一个token令牌" class="headerlink" title="提供一个token令牌"></a>提供一个token令牌</h3><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><ul><li><p>特点：短期，可撤销，有范围</p></li><li><p>如何获取token</p><ul><li><p>方式</p><ul><li><p>授权码（authorization-code）</p><ul><li>特点：最常用最安全，适用于有后端的web项目</li><li>实现：前端返回code，后端使用code请求token</li></ul></li><li><p>隐藏式（implicit）</p><ul><li>实现：直接请求token</li></ul></li><li><p>密码式（password）</p><ul><li>风险很大，直接告诉账号密码</li></ul></li><li><p>客户端凭证（client credentials）</p><ul><li>适用于没有前端的命令行应用，即在命令行下请求令牌</li></ul></li></ul></li></ul></li><li><p>使用token</p><ul><li>一般在请求头添加”Authorization: Bearer ACCESS_TOKEN”</li></ul></li><li><p>更新token</p><ul><li>一般会一起返回一个refresh_token，用于刷新token</li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>参考：google登录官方文档<br><a href="https://developers.google.com/identity/protocols/OAuth2" target="_blank" rel="noopener">https://developers.google.com/identity/protocols/OAuth2</a></p><h3 id="三方登录"><a href="#三方登录" class="headerlink" title="三方登录"></a>三方登录</h3><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><h3 id="openId"><a href="#openId" class="headerlink" title="openId"></a>openId</h3><h3 id="openId-connect"><a href="#openId-connect" class="headerlink" title="openId connect"></a>openId connect</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://q4b6m25wx.bkt.clouddn.com/xmind/oauth.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;oauth&quot;&gt;&lt;a href=&quot;#oauth&quot; class=&quot;headerlink&quot; title=&quot;oauth&quot;&gt;&lt;/a&gt;oauth&lt;/h1&gt;&lt;h2 id=&quot;oauth是什么？&quot;&gt;&lt;a href=&quot;#oauth是什么？&quot; class=&quot;headerlink&quot; title=&quot;oauth是什么？&quot;&gt;&lt;/a&gt;oauth是什么？&lt;/h2&gt;&lt;h3 id=&quot;一个开放标准，允许用户-无需提供将用户名和密码-让第三方应用访问该用户在某一网站上存储的私密的资源&quot;&gt;&lt;a href=&quot;#一个开放标准，允许用户-无需提供将用户名和密码-让第三方应用访问该用户在某一网站上存储的私密的资源&quot; class=&quot;headerlink&quot; title=&quot;一个开放标准，允许用户(无需提供将用户名和密码)让第三方应用访问该用户在某一网站上存储的私密的资源&quot;&gt;&lt;/a&gt;一个开放标准，允许用户(无需提供将用户名和密码)让第三方应用访问该用户在某一网站上存储的私密的资源&lt;/h3&gt;&lt;h2 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="协议" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>python-defaultdict</title>
    <link href="http://yoursite.com/2020/02/07/python-defaultdict/"/>
    <id>http://yoursite.com/2020/02/07/python-defaultdict/</id>
    <published>2020-02-07T02:49:21.000Z</published>
    <updated>2020-02-07T10:10:28.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h1><h3 id="问题索引"><a href="#问题索引" class="headerlink" title="问题索引"></a>问题索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计字典的相同值的出现的所有的键(类似（键-值对组成的）序列转换为（键-列表组成的）字典)</span></span><br><span class="line">dict1 = &#123;<span class="number">1</span>:<span class="string">'a'</span>,<span class="number">2</span>:<span class="string">'b'</span>,<span class="number">3</span>:<span class="string">'a'</span>&#125;</span><br><span class="line"><span class="comment"># 方式1 原生字典</span></span><br><span class="line">summary_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="keyword">if</span> summary_dict.get(v, <span class="literal">False</span>):</span><br><span class="line">        summary_dict[v].append(k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        summary_dict[v] = [k,]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 方式二 setdefault()</span></span><br><span class="line"><span class="comment"># 字典setdefault() 函数和 get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值  </span></span><br><span class="line">summary_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict1.items():</span><br><span class="line">    summary_dict.setdefault(v, []).append(k)</span><br></pre></td></tr></table></figure><p>不足：每次对于k是否已经存在统计字典中药增加一个判断，方式的if-else, 方式二的setdefault(),简单的说就是一个初始化. 而<code>defaultdict</code>的出现刚好解决了这个问题.</p><h3 id="defaultdict-是什么"><a href="#defaultdict-是什么" class="headerlink" title="defaultdict 是什么"></a>defaultdict 是什么</h3><p>官方文档:<a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/collections.html#collections.defaultdict</a></p><p>概述: <code>返回一个新的类似字典的对象。 defaultdict 是内置 dict 类的子类</code>。<br>它重载了一个方法并添加了一个可写的实例变量，其中keys的值，自行确定赋值，但是values的类型，是function_factory的类实例，而且具有默认值。比如default(int)则创建一个类似dictionary对象，里面任何的values都是int的实例，而且就算是一个不存在的key, d[key] 也有一个默认值，这个默认值是int()的默认值0</p><h3 id="defaultdict-解决了什么问题？"><a href="#defaultdict-解决了什么问题？" class="headerlink" title="defaultdict 解决了什么问题？"></a>defaultdict 解决了什么问题？</h3><p>初始化问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式三 defaultdict</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">dict1 = &#123;<span class="number">1</span>:<span class="string">'a'</span>,<span class="number">2</span>:<span class="string">'b'</span>,<span class="number">3</span>:<span class="string">'a'</span>&#125;</span><br><span class="line">summary_dict = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict1.items():</span><br><span class="line">    summary_dict[v].append(k)</span><br><span class="line"><span class="comment">#官方解释 当每个键第一次遇见时，它还没有在字典里面，所以自动创建该条目，即调用 default_factory 方法，返回一个空的 list。 list.append() 操作添加值到这个新的列表里。当再次存取该键时，就正常操作，list.append() 添加另一个值到列表中。这个计数比它的等价方法 dict.setdefault() 要快速和简单：</span></span><br></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p> 使用 list 作为 default_factory，很轻松地将（键-值对组成的）序列转换为（键-列表组成的）字典，同上例</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ol><li>关于collections</li></ol><table><thead><tr><th align="left">模块</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">namedtuple()</td><td align="left">创建命名元组子类的工厂函数</td></tr><tr><td align="left">deque</td><td align="left">类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)</td></tr><tr><td align="left">ChainMap</td><td align="left">类似字典(dict)的容器类，将多个映射集合到一个视图里面</td></tr><tr><td align="left">Counter</td><td align="left">字典的子类，提供了可哈希对象的计数功能</td></tr><tr><td align="left">OrderedDict</td><td align="left">字典的子类，保存了他们被添加的顺序</td></tr><tr><td align="left">defaultdict</td><td align="left">字典的子类，提供了一个工厂函数，为字典查询提供一个默认值</td></tr><tr><td align="left">UserDict</td><td align="left">封装了字典对象，简化了字典子类化</td></tr><tr><td align="left">UserList</td><td align="left">封装了列表对象，简化了列表子类化</td></tr><tr><td align="left">UserString</td><td align="left">封装了列表对象，简化了字符串子类化</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      python defaultdict 使用
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>algorithm--dynamic-programming</title>
    <link href="http://yoursite.com/2020/02/02/algorithm-dynamic-programming/"/>
    <id>http://yoursite.com/2020/02/02/algorithm-dynamic-programming/</id>
    <published>2020-02-01T16:08:05.000Z</published>
    <updated>2020-02-01T16:19:14.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/algorithm--dynamic-programming.png" alt="avatar"></p><h1 id="算法-动态规划"><a href="#算法-动态规划" class="headerlink" title="算法-动态规划"></a>算法-动态规划</h1><p>Those who cannot remember the past are condemned to repeat it.</p><h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么?"></a>它是什么?</h2><h3 id="Dynamic-programming，简称DP。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。"><a href="#Dynamic-programming，简称DP。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。" class="headerlink" title="Dynamic programming，简称DP。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。"></a>Dynamic programming，简称DP。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</h3><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul><li>记住已经求过的子问题的解</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><ul><li><p>爬楼梯问题</p></li><li><p>01背包问题</p><ul><li>问题描述，给定一组n个物品，每种物品都有自己的重量w和价值v，在限定的总重量/总容量内，选择其中若干个（也即每种物品可以选0个或1个），设计选择方案使得物品的总价值最高</li><li>思考:其他方式不可以么？比如，性价比计算，只拿贵的？答案，不行，只拿按照单个物品性价比高的情况下怎么使空间全部占满？所以总体计算下来单个性价比最高不一定等于总体性价比最高</li></ul></li></ul><h3 id="做过的算法题目"><a href="#做过的算法题目" class="headerlink" title="做过的算法题目"></a>做过的算法题目</h3><ul><li><p>解码方法问题</p><p><a href="https://github.com/jankin3/project-leetcode/blob/master/91-Decode-Ways-analysis.md" target="_blank" rel="noopener">https://github.com/jankin3/project-leetcode/blob/master/91-Decode-Ways-analysis.md</a></p></li><li><p>分词问题</p><p><a href="https://github.com/jankin3/project-leetcode/blob/master/139-wordbreak-analysis.md" target="_blank" rel="noopener">https://github.com/jankin3/project-leetcode/blob/master/139-wordbreak-analysis.md</a></p></li><li><p>最佳买卖股票时机含冷冻期 问题</p><p><a href="https://github.com/jankin3/project-leetcode/blob/master/309-best-time-to-buy-and-sell-stock-with-cooldown-analysis.md" target="_blank" rel="noopener">https://github.com/jankin3/project-leetcode/blob/master/309-best-time-to-buy-and-sell-stock-with-cooldown-analysis.md</a></p></li></ul><h2 id="它有什么？"><a href="#它有什么？" class="headerlink" title="它有什么？"></a>它有什么？</h2><h3 id="两个要素"><a href="#两个要素" class="headerlink" title="两个要素"></a>两个要素</h3><ul><li>状态转移方程</li><li>临界条件</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>重叠子问题和最优子结构</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>表格</p><ul><li>目的就是去不断推导，完成状态转移， 表格中的每一个cell都是一个小问题， 我们先解决规模为寻常的情况，然后根据这个结果逐步推导</li></ul></li></ul><h2 id="关联算法"><a href="#关联算法" class="headerlink" title="关联算法"></a>关联算法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>参考:<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md</a></p><ul><li><p>对比</p><ul><li>递归，从问题的结果倒推，直到问题的规模缩小到寻常。</li><li>动态规划，就是从寻常入手， 逐步扩大规模到最优子结构</li></ul></li></ul><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><ul><li>to do</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      算法-动态规划
    
    </summary>
    
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>thoughts-996</title>
    <link href="http://yoursite.com/2020/01/31/thoughts-996/"/>
    <id>http://yoursite.com/2020/01/31/thoughts-996/</id>
    <published>2020-01-31T11:24:13.000Z</published>
    <updated>2020-01-31T11:30:01.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观《奇葩说》对于996是否该886-有感"><a href="#观《奇葩说》对于996是否该886-有感" class="headerlink" title="观《奇葩说》对于996是否该886 有感"></a>观《奇葩说》<code>对于996是否该886</code> 有感</h1><h3 id="对于996，我从内心其实是支持的。"><a href="#对于996，我从内心其实是支持的。" class="headerlink" title="对于996，我从内心其实是支持的。"></a>对于996，我从内心其实是支持的。</h3><p>今天看了奇葩说刚好讲到了这个,主要精彩不是正式辩论。而是赛后几位导师的总结</p><a id="more"></a><p>薛兆丰教授说了了几个观点:</p><p>1.每个人每个时候都是在为了自己的简历打工。 竞争时代，996的原因不是老板要求你的996，而是有愿意996的员工，这份工作你不愿意，有人愿意去。竞争时代，这个时代总有人比你更加聪明更加努力。我们的努力更重要的为了自己的简历。</p><ul><li>‘当别人问你要不要对996说886的时候？（掷地有声，铿锵有力）要’</li><li>‘当别人问是否反对996制度？（掷地有声，铿锵有力）要’</li><li>‘我们自己要不要996？要’<br>(太真实了)</li></ul><p><code>很认同，个人认为工作的两个目的，1. 钱 2. 个人能力的成长</code></p><p>2.(什么样的工作更可能是996？)资本密集的地方劳动力就高。在资本多变化大劳动力特别大的地方，那些工作岗位对劳动力的付费更高。</p><p><code>对于程序员而言确实如此。对比同学，我确实很幸运，能够进入互联网行业，能够拿到如此的薪资。抓住时代。</code></p><p>3.在公司里面你对老板有多大的议价权和议价能力，议价权是你在别处的机会。如果你在别处有很多的机会，你可以去和老板谈离职加薪。</p><p><code>当我们问自己能拿多少工资的时候？我觉得更多的是看自己的价值所在，最简单就是你值多少钱，而不是去盲目和同学同行对比，看着别人拿了高薪而去眼红。</code></p><hr><p>李诞有几句话说的很好，</p><ol><li>正方辩手你当时说：’妈妈心疼你，说你的身体很重要。’ 但是我想问， ‘你妈妈的身体不重要么？我们还可以依赖妈妈多久？’， 当我们感到轻松的时候是有人在替我们负重前行</li><li>快乐是短暂的，人不可能一天都在笑。让人活下来的是意义，只有工作才是人生的意义所在。</li></ol>]]></content>
    
    <summary type="html">
    
      观《奇葩说》`对于996是否该886` 有感
    
    </summary>
    
    
    
      <category term="996" scheme="http://yoursite.com/tags/996/"/>
    
      <category term="有感" scheme="http://yoursite.com/tags/%E6%9C%89%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>mind-mapping</title>
    <link href="http://yoursite.com/2020/01/29/mind-mapping/"/>
    <id>http://yoursite.com/2020/01/29/mind-mapping/</id>
    <published>2020-01-29T14:26:29.000Z</published>
    <updated>2020-01-29T14:32:32.509Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/mind-mapping.png" alt="avatar"></p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="他是什么"><a href="#他是什么" class="headerlink" title="他是什么"></a>他是什么</h3><ul><li>输入是繁杂的关系，输出是知识网络</li></ul><h3 id="他的目的"><a href="#他的目的" class="headerlink" title="他的目的"></a>他的目的</h3><ul><li>归纳精简知识</li><li>拆分知识</li><li>避免学习误区，达到学习的原则</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>学习知识</li></ul><h3 id="使用原则：满足学习原则的要求，而不是盲目信仰"><a href="#使用原则：满足学习原则的要求，而不是盲目信仰" class="headerlink" title="使用原则：满足学习原则的要求，而不是盲目信仰"></a>使用原则：满足学习原则的要求，而不是盲目信仰</h3><h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><ul><li><p>收集例子</p></li><li><p>自我思考</p><ul><li><p>一阶知识</p><ul><li><p>分类</p><ul><li>它是什么</li><li>为什么是</li></ul></li><li><p>回归</p><ul><li>他的目的</li><li>如何达到</li></ul></li></ul></li><li><p>二阶知识</p><ul><li><p>组合关系</p><ul><li>它有什么</li></ul></li><li><p>执行步骤</p><ul><li>如何达到</li></ul></li></ul></li></ul></li></ul><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><h3 id="使用误区"><a href="#使用误区" class="headerlink" title="使用误区"></a>使用误区</h3><ul><li>是用来整理的，不是拿来记忆的</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      思维导图
    
    </summary>
    
    
    
      <category term="tool" scheme="http://yoursite.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>study-understand</title>
    <link href="http://yoursite.com/2020/01/29/study-understand/"/>
    <id>http://yoursite.com/2020/01/29/study-understand/</id>
    <published>2020-01-29T14:13:32.000Z</published>
    <updated>2020-01-29T14:25:47.228Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/study-understand.png" alt="avatar"></p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="它是什么？"><a href="#它是什么？" class="headerlink" title="它是什么？"></a>它是什么？</h2><a id="more"></a><h3 id="从有限的问题和答案中找出规律的过程。"><a href="#从有限的问题和答案中找出规律的过程。" class="headerlink" title="从有限的问题和答案中找出规律的过程。"></a>从有限的问题和答案中找出规律的过程。</h3><h2 id="它的目的？"><a href="#它的目的？" class="headerlink" title="它的目的？"></a>它的目的？</h2><h3 id="解决未知情况。"><a href="#解决未知情况。" class="headerlink" title="解决未知情况。"></a>解决未知情况。</h3><h2 id="如何学习？"><a href="#如何学习？" class="headerlink" title="如何学习？"></a>如何学习？</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>明确输入输出</li><li>将信息压缩成知识</li><li>用例子重塑大脑连接</li><li>二阶知识拆分知识</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>搞清楚输入输出</p><p>先搞清楚什么是问题和答案?而不是简单的知识描述.<br>这一点深有体会，当读书的时候，比如《高性能mysql》，看第一遍的时候只是觉得卧槽这个设计牛皮？其实我只是看了一遍知识的描述。实际的知识并没有学会多少。我的问题是什么？我为什么要看这本书？我希望收获什么？这个设计的原因是什么？解决了什么问题？没有解决什么问题？什么情况下使用？这些问题是我需要注意的地方</p></li><li><p>通过大量的已知例子去归纳总结知识</p></li><li><p>验证知识的正确性</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>思维 导图</li></ul><h2 id="学习的误区"><a href="#学习的误区" class="headerlink" title="学习的误区?"></a>学习的误区?</h2><h3 id="一般-错误-的学习方法"><a href="#一般-错误-的学习方法" class="headerlink" title="一般(错误)的学习方法:"></a>一般(错误)的学习方法:</h3><ul><li><ol><li>阅读知识的描述</li></ol></li><li><ol start="2"><li>理解描述的含义</li></ol></li><li><ol start="3"><li>反复描述希望记住</li></ol></li></ul><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><ul><li>不搞清楚输入输出</li><li>学习方式错误，比如光靠记忆</li><li>不使用例子学习</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      study
    
    </summary>
    
    
    
      <category term="study" scheme="http://yoursite.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>annual-year-2019</title>
    <link href="http://yoursite.com/2020/01/21/annual-year-2019/"/>
    <id>http://yoursite.com/2020/01/21/annual-year-2019/</id>
    <published>2020-01-21T08:58:06.000Z</published>
    <updated>2020-02-16T09:07:05.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019年总结"><a href="#2019年总结" class="headerlink" title="2019年总结"></a>2019年总结</h1><blockquote><p>适应和胜任工作要求，编程的习惯的养成，开始读书充电和总结知识体系，遇到一些问题并学会去解决  –jankin的2019年度总结</p></blockquote><a id="more"></a><h2 id="适应和胜任工作"><a href="#适应和胜任工作" class="headerlink" title="适应和胜任工作"></a>适应和胜任工作</h2><p><code>整体考虑</code>，<code>主动性</code>，<code>责任感</code>，<code>独当一面</code>，如果用词语概括今年工作的收获的话。进入工作一年半了，自己最大的感受就是如何去做好一份工作。 且不论coding能力的高低，也有很多东西值得体会和去学习。</p><h2 id="编程的习惯养成"><a href="#编程的习惯养成" class="headerlink" title="编程的习惯养成"></a>编程的习惯养成</h2><blockquote><p>你不必在技术上很在行，但你必须有能引导你变得在行的特质──机敏、有想法、善于观察、乐于主动参与解决问题。</p></blockquote><p><code>编程的理解</code>，今年对编程有了一些新的理解。编程就想是造房子，一个项目就是一个建造一个建筑。大到每个房屋之间怎么配合协调，小到这块装那块瓦怎么放置，都是工程师去设计并实现。当我们去做具体的需要的时候，尽可能的去考虑整体的设计以及兼顾细节的完美，才能编写出艺术品，而不是简单的代码机器的产物。</p><p><code>编程的能力</code>，从编程的能力来说，一些小的总结和一些有待改进</p><ul><li>总结</li></ul><ol><li>解决问题，善于利用google和stackoverflow去快速解决常见的问题</li><li>抓住问题，google和stackoverflow可以快速的找到解决方案,但并不应该只是按照这个上面的copy下来运行一下可以解决问题就完事了。每一个问题都是宝贵的财富，不要避开问题，多看文档多查资料多学习去解决问题，网络可以快速找到解决方案但是方案背后的原理需要去琢磨</li><li>整理归纳，基本功不够扎实，比如经常用到的时间模块，每次使用还是要去现场查资料，没有google开发进度为0。意识到这个问题之后今年开始写博客开始整理了，也算是一个不小的改善了，嘿嘿嘿。</li></ol><ul><li>有待改进：</li></ul><ol><li>多注重技术层次的思考，能够完成基本需求的同时应该去思考技术的本身，提升技术，毕竟技术是安家立命之本。</li></ol><h2 id="开始读书充电"><a href="#开始读书充电" class="headerlink" title="开始读书充电"></a>开始读书充电</h2><p>今年。读了《python核心编程》,《高性能mysql》,《从小工到专家》.没读完的《编程珠玑》《深入理解nginx》《鸟哥的私房菜》。买了很多技术书籍，看进去的不多。从收获上来说确实有所收获，但是也发现了一些问题。<br>问题:当需要用到一些书中东西的时候，脑袋不是特别的清晰。<br>问题原因: <code>缺少思考与整理</code>，读书不是读小说翻完了就OK了<br>新的认识:书籍是作者按照他的思路与思维模式去编写的知识载体，对于自己来说，我们拥有自己的知识网络，我们需要理解去归纳到自己的知识网络。</p><h2 id="遇到一些问题并解决"><a href="#遇到一些问题并解决" class="headerlink" title="遇到一些问题并解决"></a>遇到一些问题并解决</h2><p>遇到一个问题，<code>从日常需求来说其实都比较杂乱，经常做了之后没有足够的满足感和成就感。具体的实际影响就是比较累而且收获不大</code>。<br>深入思考了这个问题很久，我的解决方案</p><ol><li><code>心态</code>，作为一个刚进入工作的年轻人，应该去感激每一个机会去学习去积累</li><li><code>技术的思考</code>，当你做简单的事情的时候，有没有考虑你是否是站在巨人的肩膀上，才显得特别轻松。当你用bootstrap的时候有没有考虑过为什么这个框架这么受欢迎？他是怎么实现的？为什么laravel比TP好用？为什么选择mysql数据库？简单的东西需要去思考去研究。</li><li><code>业务的思考</code>，当新的需要提出的时候，应该是考虑此需求背后的具体的问题点是什么，从工程师的角度是否有更好的方式去解决，而不是只是想一个代码机器去执行PM的需求文档里面的流程。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，2019年是我的一个开启之年。开始进入工作状态，开始学会去编程，开始不断的充电，当然也开始遇到问题并学会去解决。2020，新的一年，加油!</p>]]></content>
    
    <summary type="html">
    
      2019-summary
    
    </summary>
    
    
    
      <category term="summary" scheme="http://yoursite.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>linux-filesystem</title>
    <link href="http://yoursite.com/2020/01/21/linux-filesystem/"/>
    <id>http://yoursite.com/2020/01/21/linux-filesystem/</id>
    <published>2020-01-21T06:56:32.000Z</published>
    <updated>2020-01-21T07:07:42.956Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/linux-filesystem.png" alt="avatar"></p><h1 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h1><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ul><li>索引式文件系统. 读取文件的时候读取inode中的block 位置之后可以一口气直接找到所有的block。这里对比U盘的FAT系统需要一个个读取，因为每个block 文件里面记录着下一个block的位置，相比而言会比较慢</li></ul><h3 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h3><ul><li>boot sector, superblock, inode bitmap, block bitmap, inode table, data block</li></ul><h3 id="文件-系统主要信息"><a href="#文件-系统主要信息" class="headerlink" title="文件 系统主要信息"></a>文件 系统主要信息</h3><ul><li><code>superblock</code>, 记录整个文件系统的整体信息</li><li><code>inode</code>, 文件的权限与属性,一个文件占用一个inode, 以及block 的位置</li><li><code>block</code>, 数据区块, 记录文件的实际存储数据</li></ul><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><h3 id="目录和文件类似，每个目录都有一个inode-和block-inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode"><a href="#目录和文件类似，每个目录都有一个inode-和block-inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode" class="headerlink" title="目录和文件类似，每个目录都有一个inode 和block, inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode"></a>目录和文件类似，每个目录都有一个inode 和block, inode记录的目录的属性和权限，block记录的是目录下的文件名以及文件的inode</h3><h2 id="日志式文件系统"><a href="#日志式文件系统" class="headerlink" title="日志式文件系统"></a>日志式文件系统</h2><h3 id="目的-数据一致性检查"><a href="#目的-数据一致性检查" class="headerlink" title="目的:数据一致性检查"></a>目的:数据一致性检查</h3><h3 id="实现-多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；"><a href="#实现-多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；" class="headerlink" title="实现:多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；"></a>实现:多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；</h3><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><ul><li><p>目的:列出文件系统的整体磁盘使用量</p></li><li><p>常用</p><ul><li>-h 显示各文件系统的容量</li><li>-i -h 显示各文件系统inode使用情况</li></ul></li></ul><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><ul><li>评估文件系统的磁盘使用量</li><li>du -h –max-depth=1 计算当前目录下的文件或者目录的大小，包括子目录</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      linux文件系统
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>http-client-cache</title>
    <link href="http://yoursite.com/2020/01/19/http-client-cache/"/>
    <id>http://yoursite.com/2020/01/19/http-client-cache/</id>
    <published>2020-01-19T08:48:57.000Z</published>
    <updated>2020-01-19T08:57:08.125Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/http-client-cache.png" alt="avatar"></p><h1 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h1><p>参考:<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn</a></p><h2 id="作用-网络提取内容开销大，客户端直接缓存数据"><a href="#作用-网络提取内容开销大，客户端直接缓存数据" class="headerlink" title="作用:  网络提取内容开销大，客户端直接缓存数据"></a>作用:  网络提取内容开销大，客户端直接缓存数据</h2><h2 id="问题：如何兼顾客户端缓存和快速更新"><a href="#问题：如何兼顾客户端缓存和快速更新" class="headerlink" title="问题：如何兼顾客户端缓存和快速更新"></a>问题：如何兼顾客户端缓存和快速更新</h2><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><a id="more"></a><h3 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h3><ul><li><p>ETag: 验证令牌,资源未发生变化时不会传送任何数据</p></li><li><p>Cache-Control</p><ul><li><p>概览：定义其缓存策略,也就是如何缓存各个响应以及缓存多久</p></li><li><p>详细配置</p><ul><li>“no-cache”和“no-store”</li><li>“public”与 “private”</li><li>“max-age”</li></ul></li></ul></li></ul><h3 id="实际设计"><a href="#实际设计" class="headerlink" title="实际设计:"></a>实际设计:</h3><ul><li>HTML: 被标记为“no-cache”，这意味着浏览器在每次请求时都始终会重新验证文档，并在内容变化时提取最新版本</li><li>JavaScript 可以设置较长的缓存，因为添加 了版本指纹可以随时更新。</li><li>image:图像缓存时不包含版本或唯一指纹，并设置为 1 天后到期。</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      http客户端浏览器header缓存
    
    </summary>
    
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="cache" scheme="http://yoursite.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://yoursite.com/2020/01/15/nginx/"/>
    <id>http://yoursite.com/2020/01/15/nginx/</id>
    <published>2020-01-15T14:57:48.000Z</published>
    <updated>2020-01-19T07:05:38.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><h3 id="web-服务器-也可负载均衡，反向代理"><a href="#web-服务器-也可负载均衡，反向代理" class="headerlink" title="web 服务器(也可负载均衡，反向代理)"></a>web 服务器(也可负载均衡，反向代理)</h3><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="采用异步事件驱动，可大量并行处理"><a href="#采用异步事件驱动，可大量并行处理" class="headerlink" title="采用异步事件驱动，可大量并行处理"></a>采用异步事件驱动，可大量并行处理</h3><a id="more"></a><ul><li><p>linux 采用epoll 模型</p><p>epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可</p></li></ul><h3 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h3><ul><li>丰富的第三方模块</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h3><ul><li><p>块配置 event,http, server</p></li><li><p>配置项</p><ul><li>格式: 多个值用空格隔开</li><li>单位：通用单位</li><li>变量：少数模块支持，同php</li></ul></li></ul><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p><a href="https://segmentfault.com/a/1190000013267839" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013267839</a></p><ul><li><p>作用: 根据url匹配对应处理规则</p></li><li><p>语法规则</p><ul><li>location [ = | ~ | <del>* | ^</del> ] uri { … }<br>location @name { … }</li></ul></li><li><p>匹配规则</p><ul><li><p>前缀匹配</p><ul><li>= 表示精确匹配</li><li>^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找</li><li>字符串 会相互比较选择匹配度最高的, 一般配合PHP直接使用 location / 转换到php程序</li></ul></li><li><p>正则匹配</p><ul><li>~区分大小写</li><li>~* 不区分大小写</li></ul></li></ul></li></ul><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul><li><p>debug 配置</p></li><li><p>正常运行的配置</p><ul><li>env|env=value定义环境变量 (没怎么用过)</li><li>include,嵌入其他配置, 便于模块化</li><li>pid: master 进程ID的pid文件存放路径</li><li>user username groupname, worker 进程运行的用户以及用户组</li><li>worker_rlimit_nofile limit, 可以打开的最大文件句柄数</li><li>worker_rlimit_sigpending limit, 限制信号队列</li></ul></li><li><p>优化性能配置</p><ul><li>worker_processes number,worker 进程个数</li><li>worker_cpu_affinity cpumask, 绑定worker 进程到cpu内核</li><li>ssl 硬件加速</li><li>系统调用gettimeofday 的评率</li><li>worker 进程优先级</li></ul></li><li><p>时间类配置项</p><ul><li>accept锁相关</li><li>lock 文件路径</li><li>批零建立新连接</li><li>选择时间模型</li><li>每个worker 的最大连接数</li></ul></li></ul><h3 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h3><ul><li>虚拟主机与请求的分发</li><li>文件路径的定义</li><li>内存以及磁盘的分配</li><li>网络连接的设置</li><li>MIME类型的设置</li><li>对客户端请求的限制</li><li>文件操作的优化</li><li>对客户端请求的特殊处理</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      nginx 初步了解
    
    </summary>
    
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="web服务器" scheme="http://yoursite.com/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="http://yoursite.com/2020/01/13/http/"/>
    <id>http://yoursite.com/2020/01/13/http/</id>
    <published>2020-01-13T00:28:17.000Z</published>
    <updated>2020-01-17T07:27:11.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>引用: <a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">https://juejin.im/entry/5981c5df518825359a2b9476</a></p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h3 id="客户端（用户）和服务端（网站）之间请求和应答的标准"><a href="#客户端（用户）和服务端（网站）之间请求和应答的标准" class="headerlink" title="客户端（用户）和服务端（网站）之间请求和应答的标准"></a>客户端（用户）和服务端（网站）之间请求和应答的标准</h3><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><a id="more"></a><h3 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http 1.0"></a>http 1.0</h3><h3 id="http-1-x"><a href="#http-1-x" class="headerlink" title="http 1.x"></a>http 1.x</h3><ul><li><p>改进之处</p><ul><li><p>缓存处理</p></li><li><p>带宽优化及网络连接的使用</p><ul><li>允许只请求资源的某个部分</li></ul></li><li><p>错误通知的管理</p><ul><li>新增了24个错误状态响应码</li></ul></li><li><p>Host头处理</p><ul><li>HTTP1.1的请求消息和响应消息都应支持Host头域</li></ul></li><li><p>长连接</p><ul><li>Connection： keep-alive</li></ul></li></ul></li></ul><h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><ul><li><p>基于google提出的SPDY</p></li><li><p>改进之处</p><ul><li>新的二进制格式</li><li>多路复用(区别于长连接)</li><li>header压缩</li><li>服务端推送</li></ul></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ul><li><p>是什么？</p><ul><li>超文本传输安全协议</li></ul></li><li><p>过程</p><ul><li>HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包</li></ul></li><li><p>区别</p><ul><li>http:运行在TCP之上，所有传输的内容都是明文</li><li>https:运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li></ul></li></ul><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;引用: &lt;a href=&quot;https://juejin.im/entry/5981c5df518825359a2b9476&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/entry/5981c5df518825359a2b9476&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h2&gt;&lt;h3 id=&quot;应用层协议&quot;&gt;&lt;a href=&quot;#应用层协议&quot; class=&quot;headerlink&quot; title=&quot;应用层协议&quot;&gt;&lt;/a&gt;应用层协议&lt;/h3&gt;&lt;h3 id=&quot;客户端（用户）和服务端（网站）之间请求和应答的标准&quot;&gt;&lt;a href=&quot;#客户端（用户）和服务端（网站）之间请求和应答的标准&quot; class=&quot;headerlink&quot; title=&quot;客户端（用户）和服务端（网站）之间请求和应答的标准&quot;&gt;&lt;/a&gt;客户端（用户）和服务端（网站）之间请求和应答的标准&lt;/h3&gt;&lt;h2 id=&quot;发展&quot;&gt;&lt;a href=&quot;#发展&quot; class=&quot;headerlink&quot; title=&quot;发展&quot;&gt;&lt;/a&gt;发展&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>npm</title>
    <link href="http://yoursite.com/2020/01/09/npm/"/>
    <id>http://yoursite.com/2020/01/09/npm/</id>
    <published>2020-01-09T00:37:06.000Z</published>
    <updated>2020-01-17T07:27:40.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><h3 id="全称-Node-Package-Manager，即node包管理器"><a href="#全称-Node-Package-Manager，即node包管理器" class="headerlink" title="全称 Node Package Manager，即node包管理器"></a>全称 Node Package Manager，即node包管理器</h3><p><a href="https://zh.wikipedia.org/wiki/Npm" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Npm</a></p><h2 id="常用功能与命令"><a href="#常用功能与命令" class="headerlink" title="常用功能与命令"></a>常用功能与命令</h2><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>npm install</p><ul><li><p>不加后缀直接安装，如果node_modules存在，就不再重新安装了，即使有新，也是如此, -f 强制重新安装</p></li><li><p>package.json与package-lock.json</p><p>参见：<a href="https://juejin.im/post/5d40f9a4e51d45620821ce30" target="_blank" rel="noopener">https://juejin.im/post/5d40f9a4e51d45620821ce30</a></p><ul><li><p>是什么？</p><ul><li>配置文件,锁定安装时的包的版本号</li></ul></li><li><p>配合使用</p><ul><li>如果没有lockfile, npm i会生成一个</li><li>两者兼容，根据localfile 下载</li><li>两者不兼容，会根据package.json下载，并更新lockfile</li></ul></li></ul></li><li><p>npm install <package name>  安装模块的特定版本 use @</p></li></ul></li><li><p>npm ci</p><ul><li>适合安装干净依赖的情况</li><li>快，更严格</li><li>必须有lockfile</li><li>不会修改文件</li></ul></li><li><p>install &amp;&amp; ci</p><p>npm install 读取 package.json 创建依赖项列表，并使用 package-lock.json 来通知要安装这些依赖项的哪个版本。如果某个依赖项在 package.json 中，但是不在 package-lock.json 中，运行 npm install 会将这个依赖项的确定版本更新到 package-lock.json 中。<br>npm ci 是根据 package-lock.json 去安装确定的依赖，package.json 只是用来验证是不是有不匹配的版本，假设 package-lock.json 中存在一个确定版本的依赖 A，如果 package.json 中不存在依赖 A 或者依赖 A 版本和 lock 中不兼容，npm ci 就会报错。</p></li></ul><h3 id="查看包版本"><a href="#查看包版本" class="headerlink" title="查看包版本"></a>查看包版本</h3><ul><li><p>npm list</p><ul><li>默认当前项目下的所有模块以及依赖</li><li>-g 全局</li><li>packagename 查看单独模块</li></ul></li></ul><h3 id="npm-脚本"><a href="#npm-脚本" class="headerlink" title="npm 脚本"></a>npm 脚本</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;npm&quot;&gt;&lt;a href=&quot;#npm&quot; class=&quot;headerlink&quot; title=&quot;npm&quot;&gt;&lt;/a&gt;npm&lt;/h1&gt;&lt;h2 id=&quot;是什么？&quot;&gt;&lt;a href=&quot;#是什么？&quot; class=&quot;headerlink&quot; title=&quot;是什么？&quot;&gt;&lt;/a&gt;是什么？&lt;/h2&gt;&lt;h3 id=&quot;全称-Node-Package-Manager，即node包管理器&quot;&gt;&lt;a href=&quot;#全称-Node-Package-Manager，即node包管理器&quot; class=&quot;headerlink&quot; title=&quot;全称 Node Package Manager，即node包管理器&quot;&gt;&lt;/a&gt;全称 Node Package Manager，即node包管理器&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Npm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/Npm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;常用功能与命令&quot;&gt;&lt;a href=&quot;#常用功能与命令&quot; class=&quot;headerlink&quot; title=&quot;常用功能与命令&quot;&gt;&lt;/a&gt;常用功能与命令&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql-explain</title>
    <link href="http://yoursite.com/2019/12/19/mysql-explain/"/>
    <id>http://yoursite.com/2019/12/19/mysql-explain/</id>
    <published>2019-12-19T15:04:57.000Z</published>
    <updated>2020-01-17T07:27:29.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-explain"><a href="#mysql-explain" class="headerlink" title="mysql explain"></a>mysql explain</h1><h2 id="作用：sql查询如何执行，近似结果"><a href="#作用：sql查询如何执行，近似结果" class="headerlink" title="作用：sql查询如何执行，近似结果"></a>作用：sql查询如何执行，近似结果</h2><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><a id="more"></a><h3 id="explain-extend"><a href="#explain-extend" class="headerlink" title="explain extend"></a>explain extend</h3><h3 id="explain-partitions"><a href="#explain-partitions" class="headerlink" title="explain partitions"></a>explain partitions</h3><h2 id="主要行解释"><a href="#主要行解释" class="headerlink" title="主要行解释"></a>主要行解释</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul><li><p>编号，</p><p>标识select 所属行，id越大越先执行，id相同顺序执行</p></li></ul><h3 id="select-type"><a href="#select-type" class="headerlink" title="select type"></a>select type</h3><ul><li>显示对应行是简单还是复杂查询</li></ul><h3 id="type-访问类型"><a href="#type-访问类型" class="headerlink" title="type(访问类型)"></a>type(访问类型)</h3><ul><li><p>NULL</p></li><li><p>const、system</p></li><li><p>eq_ref</p></li><li><p>ref</p></li><li><p>range</p></li><li><p>index</p><ul><li>全表扫描，按照索引</li></ul></li><li><p>ALL</p><ul><li>全表扫描，按行</li></ul></li></ul><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><ul><li>显示正在访问的表</li></ul><h3 id="ken-len"><a href="#ken-len" class="headerlink" title="ken_len"></a>ken_len</h3><ul><li>索引使用字节数</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h3 id="row"><a href="#row" class="headerlink" title="row"></a>row</h3><ul><li>估计读取行数</li></ul><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>参考：<a href="https://www.cnblogs.com/kerrycode/p/9909093.html" target="_blank" rel="noopener">https://www.cnblogs.com/kerrycode/p/9909093.html</a></p><ul><li>Using temporary</li><li>Using filesort</li><li>Using Index</li><li>Using Index Condition</li><li>Using where</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql-explain&quot;&gt;&lt;a href=&quot;#mysql-explain&quot; class=&quot;headerlink&quot; title=&quot;mysql explain&quot;&gt;&lt;/a&gt;mysql explain&lt;/h1&gt;&lt;h2 id=&quot;作用：sql查询如何执行，近似结果&quot;&gt;&lt;a href=&quot;#作用：sql查询如何执行，近似结果&quot; class=&quot;headerlink&quot; title=&quot;作用：sql查询如何执行，近似结果&quot;&gt;&lt;/a&gt;作用：sql查询如何执行，近似结果&lt;/h2&gt;&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;h2 id=&quot;相关&quot;&gt;&lt;a href=&quot;#相关&quot; class=&quot;headerlink&quot; title=&quot;相关&quot;&gt;&lt;/a&gt;相关&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>shell-script</title>
    <link href="http://yoursite.com/2019/12/12/shell-script/"/>
    <id>http://yoursite.com/2019/12/12/shell-script/</id>
    <published>2019-12-12T11:10:38.000Z</published>
    <updated>2020-01-17T07:27:49.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h1><h2 id="作用：处理用户和系统的交互"><a href="#作用：处理用户和系统的交互" class="headerlink" title="作用：处理用户和系统的交互"></a>作用：处理用户和系统的交互</h2><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><p>详细请看<a href="https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1</a></p><h2 id="相关拓展"><a href="#相关拓展" class="headerlink" title="相关拓展"></a>相关拓展</h2><a id="more"></a><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>原文:<a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/11/bash-set.html</a></p><ul><li><p>问题：</p><ul><li>目前shell 遇到错误不会自动暂停，会继续向下执行，这个其他python之类程序有很大不同，很可能产生和预期不一样的结果</li></ul></li><li><p>解决:set command用来定制环境</p><ul><li><p>-u 遇到不存在的变量报错(同-o nounset)</p></li><li><p>错误处理</p><ul><li><p>command || exit 1</p></li><li><p>-e:发生错误，就终止执行(同-o errexit)</p></li><li><p>特殊对于管道命令</p><ul><li>特殊性：Bash 会把最后一个子命令的返回值，作为整个命令的返回值</li><li>set -o pipefail:个人理解是把管道内部命令抛出去然后外部-e 会捕获，所以对于管道内部其实还是会继续执行操作</li></ul></li></ul></li><li><p>-x 输出详细输入输出(同-o xtrace)</p></li><li><p>汇总:</p><ul><li>shell 内部：set -euxo pipefail（推荐）</li><li>执行时：bash -euxo pipefail xxx.sh</li></ul></li></ul></li></ul><h3 id="ssh交互"><a href="#ssh交互" class="headerlink" title="ssh交互"></a>ssh交互</h3><ul><li><p>简介:ssh 不单可以登录，可以直接执行相关命令ssh <a href="mailto:nick@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">nick@xxx.xxx.xxx.xxx</a> “df -h”</p></li><li><p>shell  中需要与remote server 交互</p><ul><li><p>简单命令</p><ul><li>可以直接放在后面,使用引号, 例如ssh  $remote_host “mysqldump -uxxx-pxxx xxx”</li><li>缺点：(不能传递变量)</li></ul></li><li><p>复杂命令</p><ul><li>想要实现复杂的命令,可以写在外部脚本中</li><li>eg:ssh <a href="mailto:nick@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">nick@xxx.xxx.xxx.xxx</a> ‘bash -s’ &lt; test.sh var1 var2</li></ul></li></ul></li></ul><h3 id="相关操作符"><a href="#相关操作符" class="headerlink" title="相关操作符"></a>相关操作符</h3><ul><li><a href="https://blog.csdn.net/x1269778817/article/details/46535729" target="_blank" rel="noopener">https://blog.csdn.net/x1269778817/article/details/46535729</a></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shell-脚本&quot;&gt;&lt;a href=&quot;#shell-脚本&quot; class=&quot;headerlink&quot; title=&quot;shell 脚本&quot;&gt;&lt;/a&gt;shell 脚本&lt;/h1&gt;&lt;h2 id=&quot;作用：处理用户和系统的交互&quot;&gt;&lt;a href=&quot;#作用：处理用户和系统的交互&quot; class=&quot;headerlink&quot; title=&quot;作用：处理用户和系统的交互&quot;&gt;&lt;/a&gt;作用：处理用户和系统的交互&lt;/h2&gt;&lt;h2 id=&quot;语法基础&quot;&gt;&lt;a href=&quot;#语法基础&quot; class=&quot;headerlink&quot; title=&quot;语法基础&quot;&gt;&lt;/a&gt;语法基础&lt;/h2&gt;&lt;p&gt;详细请看&lt;a href=&quot;https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html#a1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关拓展&quot;&gt;&lt;a href=&quot;#相关拓展&quot; class=&quot;headerlink&quot; title=&quot;相关拓展&quot;&gt;&lt;/a&gt;相关拓展&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql-lock</title>
    <link href="http://yoursite.com/2019/12/09/mysql-lock/"/>
    <id>http://yoursite.com/2019/12/09/mysql-lock/</id>
    <published>2019-12-09T15:58:44.000Z</published>
    <updated>2020-01-17T07:27:36.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-锁机制"><a href="#mysql-锁机制" class="headerlink" title="mysql 锁机制"></a>mysql 锁机制</h1><p><a href="https://learnku.com/articles/28772#c812c1" target="_blank" rel="noopener">https://learnku.com/articles/28772#c812c1</a> 锁机制</p><h2 id="作用：解决并发访问"><a href="#作用：解决并发访问" class="headerlink" title="作用：解决并发访问"></a>作用：解决并发访问</h2><h2 id="所处的处置：一般-表锁在mysql-server层，行锁在索引层"><a href="#所处的处置：一般-表锁在mysql-server层，行锁在索引层" class="headerlink" title="所处的处置：一般,表锁在mysql server层，行锁在索引层"></a>所处的处置：一般,表锁在mysql server层，行锁在索引层</h2><a id="more"></a><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><ul><li><p>表锁</p></li><li><p>行锁</p><ul><li>实现方式：索引加锁</li></ul></li><li><p>页锁</p></li></ul><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul><li><p>写锁</p><ul><li>for update. 比读锁有更高的优先级</li></ul></li><li><p>读锁</p><ul><li>lock in share mode, 普通select innodb不会有任何锁</li></ul></li></ul><h3 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h3><ul><li><p>记录锁</p></li><li><p>间隙锁</p></li><li><p>next-key锁</p></li><li><p>意向锁</p><ul><li>是一个标记锁，为了实现表锁和行锁不同的锁粒度</li></ul></li><li><p>插入意向锁</p></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql-锁机制&quot;&gt;&lt;a href=&quot;#mysql-锁机制&quot; class=&quot;headerlink&quot; title=&quot;mysql 锁机制&quot;&gt;&lt;/a&gt;mysql 锁机制&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://learnku.com/articles/28772#c812c1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://learnku.com/articles/28772#c812c1&lt;/a&gt; 锁机制&lt;/p&gt;
&lt;h2 id=&quot;作用：解决并发访问&quot;&gt;&lt;a href=&quot;#作用：解决并发访问&quot; class=&quot;headerlink&quot; title=&quot;作用：解决并发访问&quot;&gt;&lt;/a&gt;作用：解决并发访问&lt;/h2&gt;&lt;h2 id=&quot;所处的处置：一般-表锁在mysql-server层，行锁在索引层&quot;&gt;&lt;a href=&quot;#所处的处置：一般-表锁在mysql-server层，行锁在索引层&quot; class=&quot;headerlink&quot; title=&quot;所处的处置：一般,表锁在mysql server层，行锁在索引层&quot;&gt;&lt;/a&gt;所处的处置：一般,表锁在mysql server层，行锁在索引层&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="lock" scheme="http://yoursite.com/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>string-decode</title>
    <link href="http://yoursite.com/2019/12/09/string-decode/"/>
    <id>http://yoursite.com/2019/12/09/string-decode/</id>
    <published>2019-12-09T15:13:12.000Z</published>
    <updated>2020-01-20T07:36:50.578Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://q4b6m25wx.bkt.clouddn.com/xmind/string-encode-decode.png" alt="avatar"></p><h1 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h1><p>发展与概述文章<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p><h2 id="作用-使机器识别不同的字符串"><a href="#作用-使机器识别不同的字符串" class="headerlink" title="作用:使机器识别不同的字符串"></a>作用:使机器识别不同的字符串</h2><h2 id="编码分类与发展"><a href="#编码分类与发展" class="headerlink" title="编码分类与发展"></a>编码分类与发展</h2><h3 id="编码发展"><a href="#编码发展" class="headerlink" title="编码发展"></a>编码发展</h3><ul><li><p>ASCII</p><ul><li>英语字符和二进制位对应</li></ul></li><li><p>unicode</p><ul><li>概述:字符集,所有的字符对应二进制位，但是没有规定这个二进制代码应该如何存储</li><li>优点:实现了统一 的编码</li><li>缺点:如何存储编码?兼容之后的资源浪费？</li></ul></li><li><p>utf-8</p><ul><li><p>概述:针对Unicode的可变长度字符编码实现，使用1~4个字节表示一个符号</p></li><li><p>特点:</p><ul><li>兼容ASCII. ASCII是UTF-8的一个子集</li></ul></li></ul></li><li><p>UCS-2和UCS-4:文字和代码点之间的对应关系</p></li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul><li>unicode 与utf-8: utf-8是Unicode的一种实现方式,从计算机工作方式来说一般在utf-8是用来存储和传输，unicode 一般用来转换</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="python2-编码问题"><a href="#python2-编码问题" class="headerlink" title="python2 编码问题"></a>python2 编码问题</h3><p>细节请看：<a href="https://www.jianshu.com/p/58d5f64813dc" target="_blank" rel="noopener">https://www.jianshu.com/p/58d5f64813dc</a></p><ul><li><p>type:str与unicode</p><ul><li>str 是Unicode经过编码的字节</li><li>真正的字符串</li></ul></li><li><p>类型转换</p><ul><li>2种类型的字符串都提供了 encode 和 decode 方法，通过类型转换解决问题</li></ul></li><li><p>坑</p><ul><li>编码、解码:python 会隐式地进行，默认采用 sys.setdefaultencoding()(一般是ascii)</li><li>标准输出,ptint会按照 sys.stdout.encoding 来给 unicode 编码，交给操作系统输出</li></ul></li></ul><h3 id="python去除文本中的emoji"><a href="#python去除文本中的emoji" class="headerlink" title="python去除文本中的emoji"></a>python去除文本中的emoji</h3><ul><li>问题描述: mysql utf8 不兼容emoji(utf8mb4 兼容),如何remove?</li><li>思路: 找到unicode中四字节字符删除</li><li>具体:<figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">highpoints = re.compile(u&apos;[\U00010000-\U0010ffff]&apos;) # UCS-4</span><br><span class="line">highpoints = re.compile(u&apos;[\uD800-\uDBFF][\uDC00-\uDFFF]&apos;) # UCS-2</span><br></pre></td></tr></table></figure></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://q4b6m25wx.bkt.clouddn.com/xmind/string-encode-decode.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;字符串编码&quot;&gt;&lt;a href=&quot;#字符串编码&quot; class=&quot;heade
      
    
    </summary>
    
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>python-datetime</title>
    <link href="http://yoursite.com/2019/12/01/python-datetime/"/>
    <id>http://yoursite.com/2019/12/01/python-datetime/</id>
    <published>2019-12-01T14:46:31.000Z</published>
    <updated>2020-01-17T07:27:42.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-时间和日期"><a href="#python-时间和日期" class="headerlink" title="python 时间和日期"></a>python 时间和日期</h1><h2 id="时间字符串格式化"><a href="#时间字符串格式化" class="headerlink" title="时间字符串格式化"></a>时间字符串格式化</h2><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior</a></p><h3 id="时间元组转换成字符串-strptime"><a href="#时间元组转换成字符串-strptime" class="headerlink" title="时间元组转换成字符串: strptime(),"></a>时间元组转换成字符串: strptime(),</h3><a id="more"></a><h3 id="字符串转换成时间元组-strftime"><a href="#字符串转换成时间元组-strftime" class="headerlink" title="字符串转换成时间元组:strftime(),"></a>字符串转换成时间元组:strftime(),</h3><h2 id="时间换算"><a href="#时间换算" class="headerlink" title="时间换算"></a>时间换算</h2><h3 id="主要是datetime-timedelta"><a href="#主要是datetime-timedelta" class="headerlink" title="主要是datetime.timedelta()"></a>主要是datetime.timedelta()</h3><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/datetime.html</a></p><ul><li><p>有效类型</p><ul><li>date</li><li>time</li><li>datetime</li><li>timedelta</li><li>tzinfo</li><li>timezone</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-时间和日期&quot;&gt;&lt;a href=&quot;#python-时间和日期&quot; class=&quot;headerlink&quot; title=&quot;python 时间和日期&quot;&gt;&lt;/a&gt;python 时间和日期&lt;/h1&gt;&lt;h2 id=&quot;时间字符串格式化&quot;&gt;&lt;a href=&quot;#时间字符串格式化&quot; class=&quot;headerlink&quot; title=&quot;时间字符串格式化&quot;&gt;&lt;/a&gt;时间字符串格式化&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/zh-cn/3/library/datetime.html#strftime-strptime-behavior&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;时间元组转换成字符串-strptime&quot;&gt;&lt;a href=&quot;#时间元组转换成字符串-strptime&quot; class=&quot;headerlink&quot; title=&quot;时间元组转换成字符串: strptime(),&quot;&gt;&lt;/a&gt;时间元组转换成字符串: strptime(),&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux-file-permission</title>
    <link href="http://yoursite.com/2019/11/24/linux-file-permission/"/>
    <id>http://yoursite.com/2019/11/24/linux-file-permission/</id>
    <published>2019-11-24T15:56:57.000Z</published>
    <updated>2020-01-17T07:27:20.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-文件权限"><a href="#linux-文件权限" class="headerlink" title="linux 文件权限"></a>linux 文件权限</h1><h2 id="文件权限：每个文件可以针对每个用户具有不同的权限"><a href="#文件权限：每个文件可以针对每个用户具有不同的权限" class="headerlink" title="文件权限：每个文件可以针对每个用户具有不同的权限"></a>文件权限：每个文件可以针对每个用户具有不同的权限</h2><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="为什么要有这么细致的分级？"><a href="#为什么要有这么细致的分级？" class="headerlink" title="为什么要有这么细致的分级？"></a>为什么要有这么细致的分级？</h3><ul><li>安全防护，因为linux多用户，多任务的环境。每个用户的权限隐私很重要</li></ul><h3 id="文件用户身份"><a href="#文件用户身份" class="headerlink" title="文件用户身份"></a>文件用户身份</h3><ul><li><p>own/group/other</p><a id="more"></a><h3 id="权限等级与意义"><a href="#权限等级与意义" class="headerlink" title="权限等级与意义"></a>权限等级与意义</h3></li><li><p>read</p><ul><li>对文件: 读取文件</li><li>对目录:读取该目录结构</li></ul></li><li><p>write</p><ul><li>对文件: 包括编辑新增等，但是不包括删除, 那么怎么才能删除文件呢？</li><li>对目录:更改目录结构的，包括增删改，注意删除的权限在这里</li></ul></li><li><p>execute</p><ul><li>对文件:可执行</li><li>对目录:注意，代表用户是否可以进入该目录，区分与r权限</li></ul></li></ul><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><h3 id="定义-一个文件拥有的属性"><a href="#定义-一个文件拥有的属性" class="headerlink" title="定义:一个文件拥有的属性"></a>定义:一个文件拥有的属性</h3><h3 id="内容包括-权限，连接，所有者，用户组，文件容量，修改日期，文件名"><a href="#内容包括-权限，连接，所有者，用户组，文件容量，修改日期，文件名" class="headerlink" title="内容包括:权限，连接，所有者，用户组，文件容量，修改日期，文件名"></a>内容包括:权限，连接，所有者，用户组，文件容量，修改日期，文件名</h3><h3 id="command-chgrp-chown-chmod"><a href="#command-chgrp-chown-chmod" class="headerlink" title="command:chgrp/chown/chmod"></a>command:chgrp/chown/chmod</h3><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;linux-文件权限&quot;&gt;&lt;a href=&quot;#linux-文件权限&quot; class=&quot;headerlink&quot; title=&quot;linux 文件权限&quot;&gt;&lt;/a&gt;linux 文件权限&lt;/h1&gt;&lt;h2 id=&quot;文件权限：每个文件可以针对每个用户具有不同的权限&quot;&gt;&lt;a href=&quot;#文件权限：每个文件可以针对每个用户具有不同的权限&quot; class=&quot;headerlink&quot; title=&quot;文件权限：每个文件可以针对每个用户具有不同的权限&quot;&gt;&lt;/a&gt;文件权限：每个文件可以针对每个用户具有不同的权限&lt;/h2&gt;&lt;h2 id=&quot;用户和用户组&quot;&gt;&lt;a href=&quot;#用户和用户组&quot; class=&quot;headerlink&quot; title=&quot;用户和用户组&quot;&gt;&lt;/a&gt;用户和用户组&lt;/h2&gt;&lt;h3 id=&quot;为什么要有这么细致的分级？&quot;&gt;&lt;a href=&quot;#为什么要有这么细致的分级？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有这么细致的分级？&quot;&gt;&lt;/a&gt;为什么要有这么细致的分级？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;安全防护，因为linux多用户，多任务的环境。每个用户的权限隐私很重要&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;文件用户身份&quot;&gt;&lt;a href=&quot;#文件用户身份&quot; class=&quot;headerlink&quot; title=&quot;文件用户身份&quot;&gt;&lt;/a&gt;文件用户身份&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;own/group/other&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest 与 js</title>
    <link href="http://yoursite.com/2019/11/22/XMLHttpRequest/"/>
    <id>http://yoursite.com/2019/11/22/XMLHttpRequest/</id>
    <published>2019-11-21T16:53:02.000Z</published>
    <updated>2020-01-17T07:27:55.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XMLHttpRequest是什么？"><a href="#XMLHttpRequest是什么？" class="headerlink" title="XMLHttpRequest是什么？"></a>XMLHttpRequest是什么？</h3><p>XMLHttpRequest是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。<br>关联: 有了XMLHttpRequest对象。ajax操作因此得以诞生。所以在这里 ajax，是一种技术方案</p><h3 id="js-ajax发送请求"><a href="#js-ajax发送请求" class="headerlink" title="js ajax发送请求"></a>js ajax发送请求</h3><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// get</span><br><span class="line">var httpRequest = new XMLHttpRequest();//第一步：建立所需的对象</span><br><span class="line">httpRequest.open(&apos;GET&apos;, &apos;url&apos;, true);//第二步：打开连接  将请求参数写在url中  ps:&quot;./Ptest.php?name=test&amp;nameone=testone&quot;</span><br><span class="line">httpRequest.send();//第三步：发送请求  将请求参数写在URL中</span><br><span class="line">httpRequest.onreadystatechange = function () &#123;</span><br><span class="line">    if (httpRequest.readyState == 4 &amp;&amp; httpRequest.status == 200) &#123;</span><br><span class="line">        var json = httpRequest.responseText;</span><br><span class="line">        console.log(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">// post</span><br><span class="line">var httpRequest = new XMLHttpRequest();//第一步：创建需要的对象</span><br><span class="line">httpRequest.open(&apos;POST&apos;, &apos;url&apos;, true); //第二步：打开连接</span><br><span class="line">httpRequest.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//设置请求头 注：post方式必须设置请求头（在建立连接后设置请求头）</span><br><span class="line">httpRequest.send(&apos;name=teswe&amp;ee=ef&apos;);//发送请求 将情头体写在send中</span><br><span class="line">httpRequest.onreadystatechange = function () &#123;//请求后的回调接口，可将请求成功后要执行的程序写在其中</span><br><span class="line">    if (httpRequest.readyState == 4 &amp;&amp; httpRequest.status == 200) &#123;//验证请求是否发送成功</span><br><span class="line">        var json = httpRequest.responseText;//获取到服务端返回的数据</span><br><span class="line">        console.log(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="js-发送非ajax请求"><a href="#js-发送非ajax请求" class="headerlink" title="js 发送非ajax请求"></a>js 发送非ajax请求</h3><p>get 请求就不必多说了。 <code>windows.location.href = &#39;url&#39;;</code><br>post, 我是模拟表单进行提交post请求</p><figure class="highlight plain"><figcaption><span>js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var temp = document.createElement(&quot;form&quot;);</span><br><span class="line">temp.action = &apos;%s&apos;;</span><br><span class="line">temp.method = &quot;post&quot;;</span><br><span class="line">temp.style.display = &quot;none&quot;;</span><br><span class="line">form_data = &#123;</span><br><span class="line">    &apos;action&apos;: &apos;applycoupon&apos;,</span><br><span class="line">    &apos;couponcode&apos;: &apos;%s&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">for(var key in form_data)&#123;</span><br><span class="line">    var opt = document.createElement(&quot;textarea&quot;);</span><br><span class="line">    opt.name = key;</span><br><span class="line">    opt.value = form_data[key];</span><br><span class="line">    temp.appendChild(opt);</span><br><span class="line">&#125;</span><br><span class="line">document.body.appendChild(temp);</span><br><span class="line">temp.submit();</span><br></pre></td></tr></table></figure><p>这里主要理解XMLHttpRequest是什么，具体代码细节不细说了，请参考</p><blockquote><p><a href="https://segmentfault.com/a/1190000004322487#articleHeader18" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004322487#articleHeader18</a><br><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XMLHttpRequest是什么？&quot;&gt;&lt;a href=&quot;#XMLHttpRequest是什么？&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest是什么？&quot;&gt;&lt;/a&gt;XMLHttpRequest是什么？&lt;/h3&gt;&lt;p&gt;XMLHtt
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>regular-expression-note</title>
    <link href="http://yoursite.com/2019/11/17/regular-expression-note/"/>
    <id>http://yoursite.com/2019/11/17/regular-expression-note/</id>
    <published>2019-11-17T15:30:14.000Z</published>
    <updated>2020-01-17T07:27:45.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h4><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p><a id="more"></a><p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。<br>(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p><p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。</p><p>下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请详细分析表达式(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)，这个表达式最能表现零宽断言的真正用途。</span><br><span class="line">一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.*(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)。</span><br></pre></td></tr></table></figure><h4 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</span><br><span class="line">\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。</span><br><span class="line"></span><br><span class="line">零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d&#123;3&#125;(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</span><br><span class="line"></span><br><span class="line">同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d&#123;7&#125;匹配前面不是小写字母的七位数字。</span><br></pre></td></tr></table></figure><h4 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</span><br><span class="line"></span><br><span class="line">有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</span><br><span class="line"></span><br><span class="line">a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</span><br></pre></td></tr></table></figure><h4 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h4><p>使用小括号指定一个子表达式后，<code>匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理</code>。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p><p>呃……其实,组号分配还不像我刚说得那么简单：</p><p>分组0对应整个正则表达式<br>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号<br>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．<br>后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：</p><p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。</p><p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。<br><img src="evernotecid://A7FC8235-39E4-4893-9D89-39960F38D08F/wwwevernotecom/187238225/ENResource/p138" alt="3b7159b45fc96abe1c22fd55c0f98929.png"><br>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？<br>(原文链接)[<a href="https://deerchao.net/tutorials/regex/regex.htm#negation" target="_blank" rel="noopener">原文链接</a>]</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;零宽断言&quot;&gt;&lt;a href=&quot;#零宽断言&quot; class=&quot;headerlink&quot; title=&quot;零宽断言&quot;&gt;&lt;/a&gt;零宽断言&lt;/h4&gt;&lt;p&gt;接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
